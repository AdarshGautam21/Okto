// src/lookups.ts
var getLookupFn = (lookupData) => {
  const lookups = /* @__PURE__ */ new Map();
  const from = /* @__PURE__ */ new Set();
  const withCache2 = (fn) => {
    return (id) => {
      let entry = lookups.get(id);
      if (entry)
        return entry;
      if (from.has(id)) {
        const entry2 = {
          id
        };
        lookups.set(id, entry2);
        return entry2;
      }
      from.add(id);
      const value = fn(id);
      entry = lookups.get(id);
      if (entry) {
        Object.assign(entry, value);
      } else {
        entry = {
          id,
          ...value
        };
        lookups.set(id, entry);
      }
      from.delete(id);
      return entry;
    };
  };
  let isAccountId32SearchOn = true;
  const getLookupEntryDef = withCache2((id) => {
    const { def, path, params } = lookupData[id];
    if (def.tag === "composite") {
      if (def.value.length === 0)
        return { type: "void" };
      if (def.value.length === 1) {
        if (isAccountId32SearchOn && path.join(",") === "sp_core,crypto,AccountId32") {
          isAccountId32SearchOn = false;
          return { type: "AccountId32" };
        }
        return getLookupEntryDef(def.value[0].type);
      }
      let allKey = true;
      const values = {};
      const innerDocs = {};
      def.value.forEach((x, idx) => {
        allKey = allKey && !!x.name;
        const key = x.name || idx;
        values[key] = getLookupEntryDef(x.type);
        innerDocs[key] = x.docs;
      });
      return allKey ? {
        type: "struct",
        value: values,
        innerDocs
      } : {
        type: "tuple",
        value: Object.values(values),
        innerDocs: Object.values(innerDocs)
      };
    }
    if (def.tag === "variant") {
      if (path.length === 1 && path[0] === "Option" && params.length === 1 && params[0].name === "T") {
        const value = getLookupEntryDef(params[0].type);
        return value.type === "void" ? (
          // Option<void> would return a Codec<undefined> which makes no sense
          // Therefore, we better treat it as a bool
          { type: "primitive", value: "bool" }
        ) : {
          type: "option",
          value
        };
      }
      if (path.length === 1 && path[0] === "Result" && params.length === 2 && params[0].name === "T" && params[1].name === "E") {
        return {
          type: "result",
          value: {
            ok: getLookupEntryDef(params[0].type),
            ko: getLookupEntryDef(params[1].type)
          }
        };
      }
      if (def.value.length === 0)
        return { type: "void" };
      const enumValue = {};
      const enumDocs = {};
      def.value.forEach((x) => {
        const key = x.name;
        enumDocs[key] = x.docs;
        if (x.fields.length === 0) {
          enumValue[key] = { type: "void", idx: x.index };
          return;
        }
        if (x.fields.length === 1 && !x.fields[0].name) {
          enumValue[key] = {
            type: "lookupEntry",
            value: getLookupEntryDef(x.fields[0].type),
            idx: x.index
          };
          return;
        }
        let allKey = true;
        const values = {};
        const innerDocs = {};
        x.fields.forEach((x2, idx) => {
          allKey = allKey && !!x2.name;
          const key2 = x2.name || idx;
          values[key2] = getLookupEntryDef(x2.type);
          innerDocs[key2] = x2.docs;
        });
        enumValue[key] = allKey ? {
          type: "struct",
          value: values,
          innerDocs,
          idx: x.index
        } : {
          type: "tuple",
          value: Object.values(values),
          innerDocs: Object.values(innerDocs),
          idx: x.index
        };
      });
      return {
        type: "enum",
        value: enumValue,
        innerDocs: enumDocs
      };
    }
    if (def.tag === "sequence") {
      const value = getLookupEntryDef(def.value);
      return {
        type: "sequence",
        value
      };
    }
    if (def.tag === "array") {
      const { len } = def.value;
      const value = getLookupEntryDef(def.value.type);
      if (len === 0)
        return { type: "void" };
      if (len === 1)
        return value;
      return {
        type: "array",
        value,
        len: def.value.len
      };
    }
    if (def.tag === "tuple") {
      if (def.value.length === 0)
        return { type: "void" };
      if (def.value.length === 1)
        return getLookupEntryDef(def.value[0]);
      const value = def.value.map((x) => getLookupEntryDef(x));
      const innerDocs = def.value.map((x) => lookupData[x].docs);
      const areAllSame = value.every((v) => v.id === value[0].id);
      if (areAllSame && innerDocs.every((doc) => doc.length === 0)) {
        return {
          type: "array",
          value: value[0],
          len: value.length
        };
      }
      return {
        type: "tuple",
        value,
        innerDocs
      };
    }
    if (def.tag === "primitive") {
      return {
        type: "primitive",
        value: def.value.tag
      };
    }
    if (def.tag === "compact") {
      const translated = getLookupEntryDef(def.value);
      if (translated.type === "void")
        return { type: "compact", isBig: null };
      const isBig = Number(translated.value.slice(1)) > 32;
      return {
        type: "compact",
        isBig
      };
    }
    return {
      type: def.tag
    };
  });
  return getLookupEntryDef;
};

// src/dynamic-builder.ts
import * as scale from "@polkadot-api/substrate-bindings";

// src/with-cache.ts
var withCache = (fn, onEnterCircular, onExitCircular) => (input, cache, stack, ...rest) => {
  const { id } = input;
  if (cache.has(id))
    return cache.get(id);
  if (stack.has(id)) {
    const res = onEnterCircular(() => cache.get(id), input, ...rest);
    cache.set(id, res);
    return res;
  }
  stack.add(id);
  let result = fn(input, cache, stack, ...rest);
  stack.delete(id);
  if (cache.has(id))
    result = onExitCircular(result, cache.get(id), input, ...rest);
  cache.set(id, result);
  return result;
};

// src/dynamic-builder.ts
import { mapObject } from "@polkadot-api/utils";
var _bytes = scale.Bin();
var _buildCodec = (input, cache, stack, _accountId) => {
  if (input.type === "primitive")
    return scale[input.value];
  if (input.type === "void")
    return scale._void;
  if (input.type === "AccountId32")
    return _accountId;
  if (input.type === "compact")
    return scale.compact;
  if (input.type === "bitSequence")
    return scale.bitSequence;
  const buildNextCodec = (nextInput) => buildCodec(nextInput, cache, stack, _accountId);
  const buildVector = (inner2, len) => {
    const innerCodec = buildNextCodec(inner2);
    return len ? scale.Vector(innerCodec, len) : scale.Vector(innerCodec);
  };
  const buildTuple = (value) => scale.Tuple(...value.map(buildNextCodec));
  const buildStruct = (value) => {
    const inner2 = Object.fromEntries(
      Object.entries(value).map(([key, value2]) => [key, buildNextCodec(value2)])
    );
    return scale.Struct(inner2);
  };
  if (input.type === "sequence" && input.value.type === "primitive" && input.value.value === "u8") {
    return _bytes;
  }
  if (input.type === "array") {
    if (input.value.type === "primitive" && input.value.value === "u8")
      return scale.Bin(input.len);
    return buildVector(input.value, input.len);
  }
  if (input.type === "sequence")
    return buildVector(input.value);
  if (input.type === "tuple")
    return buildTuple(input.value);
  if (input.type === "struct")
    return buildStruct(input.value);
  if (input.type === "option")
    return scale.Option(buildNextCodec(input.value));
  if (input.type === "result")
    return scale.Result(
      buildNextCodec(input.value.ok),
      buildNextCodec(input.value.ko)
    );
  const dependencies = Object.values(input.value).map((v) => {
    if (v.type === "void")
      return scale._void;
    if (v.type === "lookupEntry")
      return buildNextCodec(v.value);
    return v.type === "tuple" ? buildTuple(v.value) : buildStruct(v.value);
  });
  const inner = Object.fromEntries(
    Object.keys(input.value).map((key, idx) => {
      return [key, dependencies[idx]];
    })
  );
  const indexes = Object.values(input.value).map((x) => x.idx);
  const areIndexesSorted = indexes.every((idx, i) => idx === i);
  return areIndexesSorted ? scale.Variant(inner) : scale.Variant(inner, indexes);
};
var buildCodec = withCache(_buildCodec, scale.Self, (res) => res);
var getDynamicBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  let _accountId = scale.AccountId();
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildCodec(getLookupEntryDef(id), cache, /* @__PURE__ */ new Set(), _accountId);
  const prefix = metadata.pallets.find((x) => x.name === "System")?.constants.find((x) => x.name === "SS58Prefix");
  let ss58Prefix;
  if (prefix) {
    try {
      const prefixVal = buildDefinition(prefix.type).dec(prefix.value);
      if (typeof prefixVal === "number") {
        ss58Prefix = prefixVal;
        _accountId = scale.AccountId(prefixVal);
      }
    } catch (_) {
    }
  }
  const storagePallets = /* @__PURE__ */ new Map();
  const buildStorage = (pallet, entry) => {
    let storagePallet = storagePallets.get(pallet);
    if (!storagePallet)
      storagePallets.set(pallet, storagePallet = scale.Storage(pallet));
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
    const storageWithFallback = (len, ...args) => {
      const result = storagePallet(...args);
      return {
        ...result,
        len,
        fallback: storageEntry.modifier === 1 ? result.dec(storageEntry.fallback) : void 0
      };
    };
    if (storageEntry.type.tag === "plain")
      return storageWithFallback(
        0,
        entry,
        buildDefinition(storageEntry.type.value).dec
      );
    const { key, value, hashers } = storageEntry.type.value;
    const val = buildDefinition(value);
    const hashes = hashers.map((x) => scale[x.tag]);
    const hashArgs = hashes.length === 1 ? [[buildDefinition(key), hashes[0]]] : getLookupEntryDef(key).value.map(
      (x, idx) => [
        buildDefinition(x.id),
        hashes[idx]
      ]
    );
    return storageWithFallback(hashes.length, entry, val.dec, ...hashArgs);
  };
  const buildEnumEntry = (entry) => {
    if (entry.type === "void")
      return scale._void;
    if (entry.type === "lookupEntry")
      return buildDefinition(entry.value.id);
    return entry.type === "tuple" ? scale.Tuple(
      ...Object.values(entry.value).map((l) => buildDefinition(l.id))
    ) : scale.Struct(
      mapObject(entry.value, (x) => buildDefinition(x.id))
    );
  };
  const buildConstant = (pallet, constantName) => {
    const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
    return buildDefinition(storageEntry.type);
  };
  const buildVariant = (type) => (pallet, name) => {
    const palletEntry = metadata.pallets.find((x) => x.name === pallet);
    const lookup = getLookupEntryDef(palletEntry[type]);
    if (lookup.type !== "enum")
      throw null;
    const entry = lookup.value[name];
    return {
      location: [palletEntry.index, entry.idx],
      codec: buildEnumEntry(lookup.value[name])
    };
  };
  const buildRuntimeCall = (api, method) => {
    const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
    if (!entry)
      throw null;
    return {
      args: scale.Tuple(...entry.inputs.map((x) => buildDefinition(x.type))),
      value: buildDefinition(entry.output)
    };
  };
  return {
    buildDefinition,
    buildStorage,
    buildEvent: buildVariant("events"),
    buildError: buildVariant("errors"),
    buildRuntimeCall,
    buildCall: buildVariant("calls"),
    buildConstant,
    ss58Prefix
  };
};

// src/checksum-builder.ts
import { h64 } from "@polkadot-api/substrate-bindings";
var textEncoder = new TextEncoder();
var encodeText = textEncoder.encode.bind(textEncoder);
var getChecksum = (values) => {
  const res = new Uint8Array(values.length * 8);
  const dv = new DataView(res.buffer);
  for (let i = 0; i < values.length; i++)
    dv.setBigUint64(i * 8, values[i]);
  return h64(res);
};
var getStringChecksum = (values) => getChecksum(values.map((v) => h64(encodeText(v))));
var shapeIds = {
  primitive: 0n,
  vector: 1n,
  tuple: 2n,
  struct: 3n,
  option: 4n,
  result: 5n,
  enum: 6n,
  void: 7n
};
var runtimePrimitiveIds = {
  undefined: 0n,
  number: 1n,
  string: 2n,
  bigint: 3n,
  boolean: 4n,
  bitSequence: 5n,
  // {bitsLen: number, bytes: Uint8Array}
  byteSequence: 6n,
  // Binary
  accountId: 7n
  // SS58String
};
var metadataPrimitiveIds = {
  bool: runtimePrimitiveIds.boolean,
  char: runtimePrimitiveIds.string,
  str: runtimePrimitiveIds.string,
  u8: runtimePrimitiveIds.number,
  u16: runtimePrimitiveIds.number,
  u32: runtimePrimitiveIds.number,
  u64: runtimePrimitiveIds.bigint,
  u128: runtimePrimitiveIds.bigint,
  u256: runtimePrimitiveIds.bigint,
  i8: runtimePrimitiveIds.number,
  i16: runtimePrimitiveIds.number,
  i32: runtimePrimitiveIds.number,
  i64: runtimePrimitiveIds.bigint,
  i128: runtimePrimitiveIds.bigint,
  i256: runtimePrimitiveIds.bigint
};
var structLikeBuilder = (shapeId, input, innerChecksum) => {
  const sortedEntries = Object.entries(input).sort(
    ([a], [b]) => a.localeCompare(b)
  );
  const keysChecksum = getStringChecksum(sortedEntries.map(([key]) => key));
  const valuesChecksum = getChecksum(
    sortedEntries.map(([, entry]) => innerChecksum(entry))
  );
  return getChecksum([shapeId, keysChecksum, valuesChecksum]);
};
var buildGraph = (entry, result = /* @__PURE__ */ new Map()) => {
  if (result.has(entry.id))
    return result;
  switch (entry.type) {
    case "array":
    case "option":
    case "sequence":
      result.set(entry.id, [entry, /* @__PURE__ */ new Set([entry.value.id])]);
      buildGraph(entry.value, result);
      break;
    case "enum": {
      const children = Object.values(entry.value).flatMap((value) => {
        if (value.type === "void")
          return [];
        if (value.type === "lookupEntry")
          return value.value;
        if (value.type === "struct")
          return Object.values(value.value);
        return value.value;
      });
      result.set(entry.id, [entry, new Set(children.map((child) => child.id))]);
      children.forEach((child) => buildGraph(child, result));
      break;
    }
    case "result":
      result.set(entry.id, [
        entry,
        /* @__PURE__ */ new Set([entry.value.ok.id, entry.value.ko.id])
      ]);
      buildGraph(entry.value.ok, result);
      buildGraph(entry.value.ko, result);
      break;
    case "struct": {
      const children = Object.values(entry.value);
      result.set(entry.id, [entry, new Set(children.map((child) => child.id))]);
      children.forEach((child) => buildGraph(child, result));
      break;
    }
    case "tuple":
      result.set(entry.id, [
        entry,
        new Set(entry.value.map((child) => child.id))
      ]);
      entry.value.forEach((child) => buildGraph(child, result));
      break;
    default:
      result.set(entry.id, [entry, /* @__PURE__ */ new Set()]);
  }
  return result;
};
var _buildChecksum = (input, buildNextChecksum) => {
  if (input.type === "primitive")
    return getChecksum([shapeIds.primitive, metadataPrimitiveIds[input.value]]);
  if (input.type === "void")
    return getChecksum([shapeIds.void]);
  if (input.type === "compact")
    return getChecksum([
      shapeIds.primitive,
      runtimePrimitiveIds[input.isBig || input.isBig === null ? "bigint" : "number"]
    ]);
  if (input.type === "bitSequence")
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.bitSequence]);
  if (input.type === "AccountId32") {
    return getChecksum([shapeIds.primitive, runtimePrimitiveIds.accountId]);
  }
  if (input.type === "array") {
    const innerValue = input.value;
    if (innerValue.type === "primitive" && innerValue.value === "u8") {
      return getChecksum([
        shapeIds.primitive,
        runtimePrimitiveIds.byteSequence,
        BigInt(input.len)
      ]);
    }
    const innerChecksum = buildNextChecksum(innerValue);
    return getChecksum([shapeIds.vector, innerChecksum, BigInt(input.len)]);
  }
  if (input.type === "sequence") {
    const innerValue = input.value;
    if (innerValue.type === "primitive" && innerValue.value === "u8") {
      return getChecksum([shapeIds.primitive, runtimePrimitiveIds.byteSequence]);
    }
    const innerChecksum = buildNextChecksum(innerValue);
    return getChecksum([shapeIds.vector, innerChecksum]);
  }
  const buildTuple = (entries) => getChecksum([shapeIds.tuple, ...entries.map(buildNextChecksum)]);
  const buildStruct = (entries) => structLikeBuilder(shapeIds.struct, entries, buildNextChecksum);
  if (input.type === "tuple")
    return buildTuple(input.value);
  if (input.type === "struct")
    return buildStruct(input.value);
  if (input.type === "option")
    return getChecksum([shapeIds.option, buildNextChecksum(input.value)]);
  if (input.type === "result")
    return getChecksum([
      shapeIds.result,
      buildNextChecksum(input.value.ok),
      buildNextChecksum(input.value.ko)
    ]);
  return structLikeBuilder(shapeIds.enum, input.value, (entry) => {
    if (entry.type === "lookupEntry")
      return buildNextChecksum(entry.value);
    switch (entry.type) {
      case "void":
        return getChecksum([shapeIds.void]);
      case "tuple":
        return buildTuple(entry.value);
      case "struct":
        return buildStruct(entry.value);
    }
  });
};
var getCycles = (graph) => {
  const tarjanState = /* @__PURE__ */ new Map();
  let index = 0;
  const stack = [];
  const result = [];
  function strongConnect(v) {
    const state = {
      index,
      lowLink: index,
      onStack: true
    };
    tarjanState.set(v, state);
    index++;
    stack.push(v);
    const edges = graph.get(v)[1];
    for (let w of edges) {
      const edgeState = tarjanState.get(w);
      if (!edgeState) {
        strongConnect(w);
        state.lowLink = Math.min(state.lowLink, tarjanState.get(w).lowLink);
      } else if (edgeState.onStack) {
        state.lowLink = Math.min(state.lowLink, edgeState.index);
      }
    }
    if (state.lowLink === state.index) {
      const component = /* @__PURE__ */ new Set();
      let poppedNode = -1;
      do {
        poppedNode = stack.pop();
        tarjanState.get(poppedNode).onStack = false;
        component.add(poppedNode);
      } while (poppedNode !== v);
      if (component.size > 1)
        result.push(component);
    }
  }
  for (const node of graph.keys()) {
    if (!tarjanState.has(node)) {
      strongConnect(node);
    }
  }
  return result;
};
var getCyclicGroups = (cycles) => {
  const ungroupedCycles = new Set(cycles.map((_, i) => i));
  const edges = new Map(cycles.map((_, i) => [i, /* @__PURE__ */ new Set()]));
  cycles.forEach((cycle, i) => {
    cycles.slice(i + 1).forEach((otherCycle, _j) => {
      const j = _j + i + 1;
      const combined = /* @__PURE__ */ new Set([...cycle, ...otherCycle]);
      if (combined.size !== cycle.size + otherCycle.size) {
        edges.get(i).add(j);
        edges.get(j).add(i);
      }
    });
  });
  const groups = [];
  while (ungroupedCycles.size) {
    const group = /* @__PURE__ */ new Set();
    const toVisit = [ungroupedCycles.values().next().value];
    while (toVisit.length) {
      const idx = toVisit.pop();
      if (!ungroupedCycles.has(idx))
        continue;
      ungroupedCycles.delete(idx);
      const cycle = cycles[idx];
      cycle.forEach((v) => group.add(Number(v)));
      edges.get(idx).forEach((n) => toVisit.push(n));
    }
    groups.push(group);
  }
  return groups;
};
var sortCyclicGroups = (groups, graph) => {
  const getReachableNodes = (group) => {
    const first = group.values().next().value;
    const entry = graph.get(first)[0];
    return Array.from(buildGraph(entry).keys());
  };
  const result = new Array();
  function dependentsFirst(group) {
    if (result.includes(group))
      return;
    const dependents = groups.filter(
      (candidate) => candidate !== group && getReachableNodes(group).some((node) => candidate.has(node))
    );
    dependents.forEach((group2) => dependentsFirst(group2));
    if (result.includes(group))
      return;
    result.push(group);
  }
  groups.forEach((group) => dependentsFirst(group));
  return result;
};
var buildChecksum = (entry, cache) => {
  if (cache.has(entry.id))
    return cache.get(entry.id);
  const graph = buildGraph(entry);
  const cycles = getCycles(graph);
  const cyclicGroups = getCyclicGroups(cycles);
  const sortedCyclicGroups = sortCyclicGroups(cyclicGroups, graph);
  const recursiveBuildChecksum = (entry2, writeCache, skipCache = false) => {
    if (!skipCache && cache.has(entry2.id)) {
      return cache.get(entry2.id);
    }
    const result = _buildChecksum(
      entry2,
      (nextEntry) => recursiveBuildChecksum(nextEntry, writeCache)
    );
    writeCache(entry2.id, result);
    return result;
  };
  sortedCyclicGroups.forEach((group) => {
    group.forEach((id) => cache.set(id, 0n));
    for (let i = 0; i < group.size; i++) {
      const results = /* @__PURE__ */ new Map();
      group.forEach(
        (id) => recursiveBuildChecksum(
          graph.get(id)[0],
          (id2, value) => {
            const writeCache = group.has(id2) ? results : cache;
            writeCache.set(id2, value);
          },
          true
        )
      );
      Array.from(results.entries()).forEach(
        ([id, checksum]) => cache.set(id, checksum)
      );
    }
  });
  return recursiveBuildChecksum(entry, (id, value) => cache.set(id, value));
};
var getChecksumBuilder = (metadata) => {
  const lookupData = metadata.lookup;
  const getLookupEntryDef = getLookupFn(lookupData);
  const cache = /* @__PURE__ */ new Map();
  const buildDefinition = (id) => buildChecksum(getLookupEntryDef(id), cache);
  const buildStorage = (pallet, entry) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).storage.items.find((s) => s.name === entry);
      if (storageEntry.type.tag === "plain")
        return buildDefinition(storageEntry.type.value);
      const { key, value } = storageEntry.type.value;
      const val = buildDefinition(value);
      const returnKey = buildDefinition(key);
      return getChecksum([val, returnKey]);
    } catch (_) {
      return null;
    }
  };
  const buildRuntimeCall = (api, method) => {
    try {
      const entry = metadata.apis.find((x) => x.name === api)?.methods.find((x) => x.name === method);
      if (!entry)
        throw null;
      const argNamesChecksum = getStringChecksum(
        entry.inputs.map((x) => x.name)
      );
      const argValuesChecksum = getChecksum(
        entry.inputs.map((x) => buildDefinition(x.type))
      );
      const outputChecksum = buildDefinition(entry.output);
      return getChecksum([argNamesChecksum, argValuesChecksum, outputChecksum]);
    } catch (_) {
      return null;
    }
  };
  const buildComposite = (input) => {
    if (input.type === "void")
      return getChecksum([0n]);
    if (input.type === "tuple") {
      const values = Object.values(input.value).map(
        (entry) => buildDefinition(entry.id)
      );
      return getChecksum([shapeIds.tuple, ...values]);
    }
    return structLikeBuilder(
      shapeIds.struct,
      input.value,
      (entry) => buildDefinition(entry.id)
    );
  };
  const buildNamedTuple = (input) => {
    return structLikeBuilder(
      shapeIds.tuple,
      input.value,
      (entry) => buildDefinition(entry.id)
    );
  };
  const buildVariant = (variantType) => (pallet, name) => {
    try {
      const palletEntry = metadata.pallets.find((x) => x.name === pallet);
      const enumLookup = getLookupEntryDef(
        palletEntry[variantType]
      );
      buildDefinition(enumLookup.id);
      if (enumLookup.type !== "enum")
        throw null;
      const entry = enumLookup.value[name];
      return entry.type === "lookupEntry" ? buildDefinition(entry.value.id) : buildComposite(entry);
    } catch (_) {
      return null;
    }
  };
  const buildConstant = (pallet, constantName) => {
    try {
      const storageEntry = metadata.pallets.find((x) => x.name === pallet).constants.find((s) => s.name === constantName);
      return buildDefinition(storageEntry.type);
    } catch (_) {
      return null;
    }
  };
  const toStringEnhancer = (fn) => (...args) => fn(...args)?.toString(32) ?? null;
  return {
    buildDefinition: toStringEnhancer(buildDefinition),
    buildRuntimeCall: toStringEnhancer(buildRuntimeCall),
    buildStorage: toStringEnhancer(buildStorage),
    buildCall: toStringEnhancer(buildVariant("calls")),
    buildEvent: toStringEnhancer(buildVariant("events")),
    buildError: toStringEnhancer(buildVariant("errors")),
    buildConstant: toStringEnhancer(buildConstant),
    buildComposite: toStringEnhancer(buildComposite),
    buildNamedTuple: toStringEnhancer(buildNamedTuple),
    getAllGeneratedChecksums: () => Array.from(cache.values()).map((v) => v.toString(32))
  };
};
export {
  getChecksumBuilder,
  getDynamicBuilder,
  getLookupFn
};
//# sourceMappingURL=index.mjs.map