var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/utils/shareLatest.ts
import { ReplaySubject, share } from "rxjs";
var shareLatest = share({
  connector: () => new ReplaySubject(1),
  resetOnError: true,
  resetOnComplete: true,
  resetOnRefCountZero: true
});

// src/utils/concatMapEager.ts
import { defer, Observable as Observable2 } from "rxjs";
var concatMapEager = (mapper, concurrent = Infinity) => (source$) => new Observable2((observer) => {
  let topSubscription;
  const queues = /* @__PURE__ */ new Map();
  const innerSubscriptions = /* @__PURE__ */ new Map();
  const results = /* @__PURE__ */ new Map();
  let mapperIdx = 0;
  let subscriptionIdx = 0;
  let observerIdx = 0;
  const nextSubscription = () => {
    const inner$ = queues.get(subscriptionIdx);
    if (!inner$) {
      if (innerSubscriptions.size === 0 && (typeof topSubscription === "undefined" || topSubscription.closed)) {
        observer.complete();
      }
      return;
    }
    const idx = subscriptionIdx++;
    queues.delete(idx);
    if (observerIdx !== idx) {
      results.set(idx, []);
    }
    innerSubscriptions.set(
      idx,
      inner$.subscribe({
        next(x) {
          if (observerIdx === idx) {
            observer.next(x);
          } else {
            results.get(idx).push(x);
          }
        },
        complete() {
          innerSubscriptions.delete(idx);
          if (idx === observerIdx) {
            observerIdx++;
            while (results.has(observerIdx)) {
              results.get(observerIdx).forEach((x) => observer.next(x));
              results.delete(observerIdx);
              if (innerSubscriptions.has(observerIdx)) {
                break;
              }
              observerIdx++;
            }
          }
          nextSubscription();
        },
        error(e) {
          observer.error(e);
        }
      })
    );
  };
  topSubscription = source$.subscribe({
    next(outterValue) {
      const idx = mapperIdx++;
      queues.set(
        idx,
        defer(() => mapper(outterValue, idx))
      );
      if (innerSubscriptions.size < concurrent) {
        nextSubscription();
      }
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      if (innerSubscriptions.size === 0) {
        observer.complete();
      }
    }
  });
  return () => {
    innerSubscriptions.forEach((subscription) => subscription.unsubscribe());
    topSubscription.unsubscribe();
    queues.clear();
    results.clear();
  };
});

// src/utils/with-default-value.ts
import { Observable as Observable3 } from "rxjs";
var withDefaultValue = (defaultValue) => (source$) => new Observable3((observer) => {
  let hasEmited = false;
  const subscription = source$.subscribe({
    next(v) {
      hasEmited = true;
      observer.next(v);
    },
    error(e) {
      observer.error(e);
    },
    complete() {
      observer.complete();
    }
  });
  if (!hasEmited)
    observer.next(defaultValue);
  return subscription;
});

// src/chainHead/chainHead.ts
import { blockHeader } from "@polkadot-api/substrate-bindings";
import {
  DisjointError
} from "@polkadot-api/substrate-client";
import {
  Observable as Observable17,
  ReplaySubject as ReplaySubject2,
  Subject as Subject2,
  defer as defer2,
  distinctUntilChanged as distinctUntilChanged2,
  map as map6,
  merge as merge2,
  mergeMap as mergeMap4,
  scan as scan2,
  share as share3,
  switchMap as switchMap2,
  take as take5
} from "rxjs";

// src/chainHead/enhancers/operationLimitRecovery.ts
import { OperationLimitError } from "@polkadot-api/substrate-client";
import { Observable as Observable4 } from "rxjs";
var PendingTaskQueue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
  }
  getRemoveFn(node) {
    return () => {
      if (node.prev) {
        node.prev.next = node.next;
      } else {
        this.first = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      } else {
        this.last = node.prev;
      }
      delete node.prev;
      delete node.next;
    };
  }
  push(value) {
    const newNode = { value };
    if (this.last === void 0) {
      this.last = this.first = newNode;
    } else {
      this.last.next = newNode;
      newNode.prev = this.last;
      this.last = newNode;
    }
    return this.getRemoveFn(newNode);
  }
  unshift(value) {
    this.first = { value, next: this.first };
    this.first.next && (this.first.next.prev = this.first);
    this.last || (this.last = this.first);
    return this.getRemoveFn(this.first);
  }
  pop() {
    const result = this.first?.value;
    if (this.first) {
      this.first = this.first.next;
      if (!this.first) {
        this.last = void 0;
      } else {
        delete this.first.prev?.next;
        delete this.first.prev;
      }
    }
    return result;
  }
  isEmpty() {
    return !this.first;
  }
};
var getWithRecovery = () => {
  const tearDownOperations = /* @__PURE__ */ new Map();
  const setTeardown = (observable, cb) => {
    tearDownOperations.set(observable, () => {
      tearDownOperations.delete(observable);
      cb();
    });
  };
  const teardown = (observable) => {
    tearDownOperations.get(observable)?.();
  };
  const pendingTasks = new PendingTaskQueue();
  const unshift = pendingTasks.unshift.bind(pendingTasks);
  const push = pendingTasks.push.bind(pendingTasks);
  const addTask = (task, topPriority) => {
    const fn = topPriority ? unshift : push;
    setTeardown(task.source$, fn(task));
  };
  const onEmptySlot = () => {
    const data = pendingTasks.pop();
    if (!data)
      return;
    tearDownOperations.delete(data.source$);
    process(data);
  };
  const process = (data) => {
    const { source$, observer } = data;
    const subscription = source$.subscribe({
      next(x) {
        observer.next(x);
      },
      error(e) {
        teardown(source$);
        if (e instanceof OperationLimitError)
          return addTask(data, true);
        observer.error(e);
        onEmptySlot();
      },
      complete() {
        observer.complete();
        onEmptySlot();
      }
    });
    if (!observer.closed) {
      setTeardown(source$, () => {
        subscription.unsubscribe();
      });
    }
  };
  const withRecovery = (topPriority = false) => (source$) => new Observable4((observer) => {
    const pendingTask = { observer, source$ };
    if (pendingTasks.isEmpty()) {
      process(pendingTask);
    } else {
      addTask(pendingTask, topPriority);
    }
    return () => {
      teardown(source$);
    };
  });
  const withNormalRecovery = withRecovery();
  const withRecoveryFn = (fn) => (...args) => withNormalRecovery(fn(...args));
  return { withRecovery, withRecoveryFn };
};

// src/chainHead/enhancers/optionalHash.ts
import { mergeMap, of, take } from "rxjs";
var getWithOptionalhash$ = (finalized$, best$) => {
  return (fn) => (hash, ...args) => {
    const hash$ = hash === null || hash === "finalized" ? finalized$ : hash === "best" ? best$ : of(hash);
    return hash$.pipe(
      take(1),
      mergeMap((h) => fn(h, ...args))
    );
  };
};

// src/chainHead/enhancers/fromAbortControllerFn.ts
import { Observable as Observable6 } from "rxjs";
var fromAbortControllerFn = (fn) => (...args) => new Observable6((observer) => {
  let aborter = new AbortController();
  fn(...[...args, aborter.signal]).then(
    (value) => {
      observer.next(value);
      observer.complete();
    },
    (error) => {
      observer.error(error);
    }
  );
  return () => {
    observer.unsubscribe();
    aborter.abort();
    aborter = void 0;
  };
});

// src/chainHead/enhancers/lazyFollower.ts
var withLazyFollower = (getFollower) => (key) => (...args) => getFollower()[key](...args);

// src/chainHead/enhancers/whileBestBlock.ts
import { Observable as Observable11, filter as filter2, mergeMap as mergeMap2, switchMap, take as take3, throwError } from "rxjs";

// src/chainHead/errors.ts
var BlockNotPinnedError = class extends Error {
  constructor() {
    super("Block is not pinned");
    this.name = "BlockNotPinnedError";
  }
};
var BlockPrunedError = class extends Error {
  constructor() {
    super("Block pruned");
    this.name = "BlockPrunedError";
  }
};
var NotBestBlockError = class extends Error {
  constructor() {
    super("Block is not best block or finalized");
    this.name = "NotBestBlockError";
  }
};

// src/chainHead/streams/follow.ts
import {
  StopError
} from "@polkadot-api/substrate-client";
import { Observable as Observable7, Subscription as Subscription2, noop, share as share2 } from "rxjs";
var getFollow$ = (chainHead) => {
  let follower = null;
  let unfollow = noop;
  const follow$ = new Observable7((observer) => {
    follower = chainHead(
      true,
      (e) => {
        observer.next(e);
      },
      (e) => {
        follower = null;
        observer.error(e);
      }
    );
    unfollow = () => {
      observer.complete();
      follower?.unfollow();
    };
  }).pipe(share2());
  return {
    getFollower: () => {
      if (!follower)
        throw new Error("Missing chainHead subscription");
      return follower;
    },
    unfollow: () => {
      unfollow();
    },
    follow$
  };
};
var retryOnStopError = () => (source$) => new Observable7((observer) => {
  const subscription = new Subscription2();
  const subscribe = () => source$.subscribe({
    next: (v) => observer.next(v),
    error: (e) => {
      if (e instanceof StopError) {
        observer.next({ type: "stop-error" });
        subscription.add(subscribe());
      } else {
        observer.error(e);
      }
    },
    complete: () => observer.complete()
  });
  subscription.add(subscribe());
  return subscription;
});

// src/chainHead/streams/get-runtime-creator.ts
import {
  getChecksumBuilder,
  getDynamicBuilder,
  getLookupFn
} from "@polkadot-api/metadata-builders";
import {
  AccountId,
  Option,
  u32,
  _void,
  Bytes,
  metadata as metadataCodec
} from "@polkadot-api/substrate-bindings";
import { toHex } from "@polkadot-api/utils";
import { map, shareReplay } from "rxjs";
var opaqueMeta = Option(Bytes());
var v15Args = toHex(u32.enc(15));
var getRuntimeCreator = (call$) => (hash) => {
  const usages = /* @__PURE__ */ new Set([hash]);
  const runtimeContext$ = call$(
    hash,
    "Metadata_metadata_at_version",
    v15Args
  ).pipe(
    map((response) => {
      const metadataRaw = opaqueMeta.dec(response);
      const metadata = metadataCodec.dec(metadataRaw);
      if (metadata.metadata.tag !== "v15")
        throw new Error("Wrong metadata version");
      const v15 = metadata.metadata.value;
      const checksumBuilder = getChecksumBuilder(v15);
      const dynamicBuilder = getDynamicBuilder(v15);
      const events = dynamicBuilder.buildStorage("System", "Events");
      const assetPayment = metadata.metadata.value.extrinsic.signedExtensions.find(
        (x) => x.identifier === "ChargeAssetTxPayment"
      );
      let _assetId = null;
      if (assetPayment) {
        const assetTxPayment = getLookupFn(metadata.metadata.value.lookup)(
          assetPayment.type
        );
        if (assetTxPayment.type === "struct") {
          const optionalAssetId = assetTxPayment.value.asset_id;
          if (optionalAssetId.type === "option")
            _assetId = optionalAssetId.value.id;
        }
      }
      const asset = _assetId === null ? [_void.enc, null] : [
        dynamicBuilder.buildDefinition(_assetId).enc,
        checksumBuilder.buildDefinition(_assetId)
      ];
      return {
        asset,
        metadataRaw,
        metadata: v15,
        checksumBuilder,
        dynamicBuilder,
        events: {
          key: events.enc(),
          dec: events.dec
        },
        accountId: AccountId(dynamicBuilder.ss58Prefix)
      };
    }),
    shareReplay(1)
  );
  const result = {
    at: hash,
    runtime: runtimeContext$,
    addBlock: (block) => {
      usages.add(block);
      return result;
    },
    deleteBlocks: (blocks) => {
      blocks.forEach((block) => {
        usages.delete(block);
      });
      return usages.size;
    },
    usages
  };
  runtimeContext$.subscribe();
  return result;
};

// src/chainHead/streams/pinned-blocks.ts
import { concatMap, map as map2, merge, of as of2, scan } from "rxjs";
var deleteBlock = (blocks, blockHash) => {
  blocks.get(blocks.get(blockHash).parent)?.children.delete(blockHash);
  blocks.delete(blockHash);
};
var getBlocksToUnpin = (blocks, pruned) => {
  const result = [...pruned];
  let current = blocks.blocks.get(blocks.blocks.get(blocks.finalized).parent);
  const trail = [];
  while (current) {
    trail.push(current.hash);
    if (current.refCount === 0 && !current.unpinned) {
      result.push(current.hash);
      current.unpinned = true;
    }
    current = blocks.blocks.get(current.parent);
  }
  const deletedBlocks = [...pruned];
  for (let i = trail.length - 1; i >= 0; i--) {
    current = blocks.blocks.get(trail[i]);
    if (!current.unpinned)
      return result;
    deletedBlocks.push(current.hash);
  }
  deletedBlocks.forEach((hash) => {
    deleteBlock(blocks.blocks, hash);
  });
  Object.entries(blocks.runtimes).map(([key, value]) => ({
    key,
    usages: value.deleteBlocks(deletedBlocks)
  })).filter((x) => x.usages === 0).map((x) => x.key).forEach((unusedRuntime) => {
    delete blocks.runtimes[unusedRuntime];
  });
  return result;
};
var getPinnedBlocks$ = (follow$, getHeader, call$, blockUsage$, onUnpin) => {
  const pinnedBlocks$ = merge(
    blockUsage$,
    follow$.pipe(withInitializedNumber(getHeader), retryOnStopError())
  ).pipe(
    scan((acc, event) => {
      switch (event.type) {
        case "initialized":
          if (acc.recovering) {
            const isConnected = event.finalizedBlockHashes.some(
              (hash) => acc.blocks.has(hash)
            );
            if (!isConnected) {
              acc = getInitialPinnedBlocks();
            }
          }
          const [finalizedHash] = event.finalizedBlockHashes.slice(-1);
          acc.finalized = acc.best = finalizedHash;
          const lastIdx = event.finalizedBlockHashes.length - 1;
          event.finalizedBlockHashes.forEach((hash, i) => {
            if (acc.blocks.has(hash)) {
              acc.blocks.get(hash).recovering = false;
            } else {
              acc.blocks.set(hash, {
                hash,
                parent: i === 0 ? event.parentHash : event.finalizedBlockHashes[i - 1],
                children: new Set(
                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]]
                ),
                runtime: hash,
                refCount: 0,
                number: event.number + i,
                recovering: false
              });
            }
          });
          const finalizedRuntime = Object.values(acc.runtimes).find(
            (runtime) => runtime.usages.has(finalizedHash)
          );
          acc.finalizedRuntime = finalizedRuntime ?? (acc.runtimes[finalizedHash] = getRuntime(finalizedHash));
          return acc;
        case "stop-error":
          for (const block of acc.blocks.values()) {
            block.recovering = true;
          }
          acc.recovering = true;
          return acc;
        case "newBlock": {
          const { parentBlockHash: parent, blockHash: hash } = event;
          if (acc.blocks.has(hash)) {
            acc.blocks.get(hash).recovering = false;
          } else {
            const parentNode = acc.blocks.get(parent);
            parentNode.children.add(hash);
            if (event.newRuntime) {
              acc.runtimes[hash] = getRuntime(hash);
              acc.runtimes[hash].runtime.subscribe();
            }
            const block = {
              hash,
              number: parentNode.number + 1,
              parent,
              children: /* @__PURE__ */ new Set(),
              runtime: event.newRuntime ? hash : parentNode.runtime,
              refCount: 0,
              recovering: false
            };
            acc.blocks.set(hash, block);
            acc.runtimes[block.runtime].addBlock(hash);
          }
          return acc;
        }
        case "bestBlockChanged": {
          if (acc.recovering) {
            for (const [hash, block] of acc.blocks) {
              if (block.recovering) {
                deleteBlock(acc.blocks, hash);
              }
            }
            acc.recovering = false;
          }
          acc.best = event.bestBlockHash;
          return acc;
        }
        case "finalized": {
          acc.finalized = event.finalizedBlockHashes.slice(-1)[0];
          acc.finalizedRuntime = acc.runtimes[acc.blocks.get(acc.finalized).runtime];
          const actuallyPruned = [...new Set(event.prunedBlockHashes)];
          onUnpin(getBlocksToUnpin(acc, actuallyPruned));
          return acc;
        }
        case "blockUsage": {
          if (!acc.blocks.has(event.value.hash))
            return acc;
          const block = acc.blocks.get(event.value.hash);
          block.refCount += event.value.type === "hold" ? 1 : -1;
          if (block.refCount === 0 && block.number < acc.blocks.get(acc.finalized).number) {
            block.unpinned = true;
            onUnpin([block.hash]);
          }
          return acc;
        }
      }
    }, getInitialPinnedBlocks()),
    map2((x) => ({ ...x })),
    shareLatest
  );
  const getRuntime = getRuntimeCreator(withStopRecovery(pinnedBlocks$, call$));
  return pinnedBlocks$;
};
var getInitialPinnedBlocks = () => ({
  best: "",
  finalized: "",
  runtimes: {},
  blocks: /* @__PURE__ */ new Map(),
  finalizedRuntime: {},
  recovering: false
});
var withInitializedNumber = (getHeader) => (source$) => source$.pipe(
  concatMap((event) => {
    return event.type !== "initialized" ? of2(event) : getHeader(event.finalizedBlockHashes[0]).then((header) => ({
      ...event,
      number: header.number,
      parentHash: header.parentHash
    }));
  })
);

// src/chainHead/streams/block-operations.ts
import {
  distinctUntilChanged,
  filter,
  map as map3,
  take as take2,
  takeWhile
} from "rxjs";
var isFinalized = (blockHash) => (blocks$) => blocks$.pipe(
  takeWhile((b) => b.blocks.has(blockHash)),
  distinctUntilChanged((a, b) => a.finalized === b.finalized),
  filter(
    (x) => x.blocks.get(x.finalized).number >= x.blocks.get(blockHash).number
  ),
  take2(1),
  map3((pinned) => {
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.finalized);
    while (current.number > number)
      current = pinned.blocks.get(current.parent);
    return current.hash === blockHash;
  })
);
var isBestOrFinalizedBlock = (blockHash) => (blocks$) => blocks$.pipe(
  takeWhile((b) => b.blocks.has(blockHash)),
  distinctUntilChanged((a, b) => a.best === b.best),
  filter(
    (x) => x.blocks.get(x.best).number >= x.blocks.get(blockHash).number
  ),
  map3((pinned) => {
    const { number } = pinned.blocks.get(blockHash);
    let current = pinned.blocks.get(pinned.best);
    let isFinalized2 = pinned.finalized === current.hash;
    while (current.number > number) {
      current = pinned.blocks.get(current.parent);
      isFinalized2 = isFinalized2 || pinned.finalized === current.hash;
    }
    return { isBest: current.hash === blockHash, isFinalized: isFinalized2 };
  }),
  takeWhile(({ isFinalized: isFinalized2 }) => !isFinalized2, true),
  map3(({ isBest }) => isBest)
);

// src/chainHead/enhancers/whileBestBlock.ts
function withEnsureCanonicalChain(blocks$, follow$, fn) {
  return (hash, ...args) => fn(hash, ...args).pipe(
    throwWhenPrune(
      hash,
      follow$.pipe(
        retryOnStopError(),
        filter2((evt) => evt.type === "finalized"),
        mergeMap2((evt) => evt.prunedBlockHashes)
      )
    ),
    onlyIfIsBestOrFinalized(hash, blocks$)
  );
}
var onlyIfIsBestOrFinalized = (hash, blocks$) => (source$) => blocks$.pipe(
  isBestOrFinalizedBlock(hash),
  take3(1),
  switchMap(
    (isBest) => isBest ? source$ : throwError(() => new NotBestBlockError())
  )
);
var throwWhenPrune = (hash, pruned$) => (source$) => new Observable11((subscriber) => {
  const prunedSubscription = pruned$.pipe(filter2((h) => h === hash)).subscribe(() => {
    subscriber.error(new BlockPrunedError());
  });
  const sourceSubscription = source$.subscribe(subscriber);
  return () => {
    prunedSubscription.unsubscribe();
    sourceSubscription.unsubscribe();
  };
});

// src/chainHead/enhancers/withStopRecovery.ts
import { Observable as Observable12 } from "rxjs";
function withStopRecovery(blocks$, fn) {
  return (hash, ...args) => {
    const source$ = fn(hash, ...args);
    return new Observable12((observer) => {
      let sourceSub = null;
      const performSourceSub = () => {
        if (sourceSub)
          return;
        sourceSub = source$.subscribe({
          next: (v) => observer.next(v),
          error: (e) => observer.error(e),
          complete: () => observer.complete()
        });
      };
      let isRecovering = false;
      const blockSub = blocks$.subscribe({
        next: (v) => {
          const block = v.blocks.get(hash);
          if (!block) {
            if (isRecovering) {
              observer.error(new BlockNotPinnedError());
            }
          } else if (block.recovering) {
            sourceSub?.unsubscribe();
            sourceSub = null;
          } else {
            performSourceSub();
          }
          isRecovering = v.recovering;
        },
        error: (e) => observer.error(e)
      });
      return () => {
        blockSub.unsubscribe();
        sourceSub?.unsubscribe();
      };
    });
  };
}

// src/chainHead/enhancers/operationInaccessibleRecovery.ts
import { OperationInaccessibleError } from "@polkadot-api/substrate-client";
import { catchError, concatMap as concatMap2, throwError as throwError2, timer } from "rxjs";
var operable = (source$) => {
  const result = source$.pipe(
    catchError(
      (e) => e instanceof OperationInaccessibleError ? timer(750).pipe(concatMap2(() => result)) : throwError2(() => e)
    )
  );
  return result;
};
var withOperationInaccessibleRecovery = (fn) => (...args) => operable(fn(...args));

// src/chainHead/storage-queries.ts
import { Observable as Observable14, mergeAll } from "rxjs";
var getRecoveralStorage$ = (getFollower, withRecovery) => {
  const recoveralStorage$ = (hash, queries, childTrie, isHighPriority) => new Observable14(
    (observer) => getFollower().storageSubscription(
      hash,
      queries,
      childTrie ?? null,
      (items) => {
        observer.next(items);
      },
      (error) => {
        observer.error(error);
      },
      () => {
        observer.complete();
      },
      (nDiscarded) => {
        if (nDiscarded === 0)
          return;
        observer.next(
          recoveralStorage$(
            hash,
            queries.slice(-nDiscarded),
            childTrie,
            true
          )
        );
      }
    )
  ).pipe(mergeAll(), withRecovery(isHighPriority));
  return recoveralStorage$;
};

// src/chainHead/track-tx.ts
import {
  EMPTY,
  catchError as catchError2,
  concat,
  concatMap as concatMap3,
  distinct,
  filter as filter3,
  map as map4,
  mergeMap as mergeMap3,
  of as of3,
  take as take4,
  takeUntil,
  takeWhile as takeWhile2
} from "rxjs";
var getTrackTx = (blocks$, getBody) => (tx) => blocks$.pipe(
  take4(1),
  concatMap3((x) => {
    const alreadyPresent = new Set(x.blocks.keys());
    const findInBody = (hash) => alreadyPresent.has(hash) ? of3(-1) : getBody(hash).pipe(
      catchError2(() => EMPTY),
      takeUntil(
        blocks$.pipe(filter3(({ blocks }) => !blocks.has(hash)))
      ),
      map4((txs) => txs.indexOf(tx))
    );
    const findInBranch = (hash) => findInBody(hash).pipe(
      concatMap3(
        (idx) => idx > -1 ? of3({ hash, idx }) : blocks$.pipe(
          takeWhile2((x2) => x2.blocks.has(hash)),
          mergeMap3((x2) => x2.blocks.get(hash).children),
          distinct(),
          mergeMap3(findInBranch)
        )
      )
    );
    return findInBranch(x.finalized).pipe(
      mergeMap3(
        ({ hash, idx }) => concat(
          blocks$.pipe(
            isBestOrFinalizedBlock(hash),
            filter3(Boolean),
            take4(1),
            map4(() => ({
              type: "bestChainBlockIncluded",
              block: { hash, index: idx }
            }))
          ),
          blocks$.pipe(
            isFinalized(hash),
            filter3(Boolean),
            map4(() => ({
              type: "finalized",
              block: { hash, index: idx }
            }))
          )
        )
      )
    );
  }),
  takeWhile2((x) => x.type !== "finalized", true)
);

// src/chainHead/validate-tx.ts
import { map as map5 } from "rxjs";
import { fromHex, mergeUint8, toHex as toHex2 } from "@polkadot-api/utils";
var external = new Uint8Array([2]);
var getValidateTxArgs = (tx, hash) => toHex2(mergeUint8(external, fromHex(tx), fromHex(hash)));
var getValidateTx = (call$) => (tx, blockHash) => call$(
  blockHash,
  "TaggedTransactionQueue_validate_transaction",
  getValidateTxArgs(tx, blockHash)
).pipe(map5((x) => x.startsWith("0x00")));

// src/chainHead/chainHead.ts
var toBlockInfo = ({ hash, number, parent }) => ({
  hash,
  number,
  parent
});
var getChainHead$ = (chainHead) => {
  const { getFollower, unfollow, follow$ } = getFollow$(chainHead);
  const lazyFollower = withLazyFollower(getFollower);
  const { withRecovery, withRecoveryFn } = getWithRecovery();
  const blockUsage$ = new Subject2();
  const withRefcount = (fn) => (hash, ...args) => new Observable17((observer) => {
    blockUsage$.next({ type: "blockUsage", value: { type: "hold", hash } });
    const subscription = fn(hash, ...args).subscribe(observer);
    return () => {
      setTimeout(() => {
        blockUsage$.next({
          type: "blockUsage",
          value: { type: "release", hash }
        });
      }, 0);
      subscription.unsubscribe();
    };
  });
  const withInMemory = (fn) => (hash, ...args) => new Observable17((observer) => {
    let isPresent = false;
    pinnedBlocks$.pipe(take5(1)).subscribe((blocks) => {
      const block = blocks.blocks.get(hash);
      isPresent = !!block && !block.unpinned;
    });
    return isPresent ? fn(hash, ...args).subscribe(observer) : observer.error(new BlockNotPinnedError());
  });
  const getHeader = (hash) => getFollower().header(hash).then(blockHeader.dec);
  const unpin = (hashes) => getFollower().unpin(hashes).catch((e) => {
    if (e instanceof DisjointError)
      return;
    throw e;
  });
  const commonEnhancer = (fn) => withInMemory(
    withRefcount(
      withEnsureCanonicalChain(
        pinnedBlocks$,
        follow$,
        withStopRecovery(
          pinnedBlocks$,
          withOperationInaccessibleRecovery(
            withRecoveryFn(fromAbortControllerFn(fn))
          )
        )
      )
    )
  );
  const _call$ = withOperationInaccessibleRecovery(
    withRecoveryFn(fromAbortControllerFn(lazyFollower("call")))
  );
  const cache = /* @__PURE__ */ new Map();
  const pinnedBlocks$ = getPinnedBlocks$(
    follow$,
    getHeader,
    _call$,
    blockUsage$,
    (blocks) => {
      unpin(blocks);
      blocks.forEach((hash) => {
        cache.delete(hash);
      });
    }
  );
  const getRuntimeContext$ = withRefcount(
    (hash) => pinnedBlocks$.pipe(
      take5(1),
      mergeMap4(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      )
    )
  );
  const withRuntime = (mapper) => (source$) => source$.pipe(
    concatMapEager(
      (x) => getRuntimeContext$(mapper(x)).pipe(map6((runtime) => [x, runtime]))
    )
  );
  const upsertCachedStream = (hash, key, stream) => {
    const cached = cache.get(hash)?.get(key);
    if (cached)
      return cached;
    if (!cache.has(hash))
      cache.set(hash, /* @__PURE__ */ new Map());
    const result = stream.pipe(
      share3({
        connector: () => new ReplaySubject2(),
        resetOnError: true,
        resetOnRefCountZero: true,
        resetOnComplete: false
      })
    );
    cache.get(hash).set(key, result);
    return result;
  };
  const finalized$ = pinnedBlocks$.pipe(
    distinctUntilChanged2((a, b) => a.finalized === b.finalized),
    map6((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized))),
    shareLatest
  );
  const best$ = pinnedBlocks$.pipe(
    distinctUntilChanged2((a, b) => a.best === b.best),
    map6((pinned) => toBlockInfo(pinned.blocks.get(pinned.best))),
    shareLatest
  );
  const bestBlocks$ = pinnedBlocks$.pipe(
    distinctUntilChanged2((prev, current) => prev.best === current.best),
    scan2((acc, pinned) => {
      const getBlockInfo = (hash) => acc.get(hash) || toBlockInfo(pinned.blocks.get(hash));
      const best = getBlockInfo(pinned.best);
      const finalized = getBlockInfo(pinned.finalized);
      const len = best.number - finalized.number + 1;
      const result = new Array(len);
      for (let i = 0, hash = best.hash; i < len; i++) {
        result[i] = getBlockInfo(hash);
        hash = result[i].parent;
      }
      return new Map(result.map((b) => [b.hash, b]));
    }, /* @__PURE__ */ new Map()),
    map6((x) => [...x.values()]),
    shareLatest
  );
  const runtime$ = pinnedBlocks$.pipe(
    distinctUntilChanged2((a, b) => a.finalizedRuntime === b.finalizedRuntime),
    switchMap2(
      ({ finalizedRuntime: { runtime } }) => runtime.pipe(withDefaultValue(null))
    ),
    shareLatest
  );
  const metadata$ = runtime$.pipe(map6((x) => x?.metadata ?? null));
  const withOptionalHash$ = getWithOptionalhash$(
    finalized$.pipe(map6((b) => b.hash)),
    best$.pipe(map6((b) => b.hash))
  );
  const _body$ = commonEnhancer(lazyFollower("body"));
  const body$ = (hash) => upsertCachedStream(hash, "body", _body$(hash));
  const trackTx$ = getTrackTx(pinnedBlocks$, body$);
  const _storage$ = commonEnhancer(lazyFollower("storage"));
  const storage$ = withOptionalHash$(
    (hash, type, keyMapper, childTrie = null, mapper) => pinnedBlocks$.pipe(
      take5(1),
      mergeMap4(
        (pinned) => pinned.runtimes[pinned.blocks.get(hash).runtime].runtime
      ),
      mergeMap4((ctx) => {
        const key = keyMapper(ctx);
        const unMapped$ = upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}`,
          _storage$(hash, type, key, childTrie)
        );
        return mapper ? upsertCachedStream(
          hash,
          `storage-${type}-${key}-${childTrie ?? ""}-dec`,
          unMapped$.pipe(map6((x) => mapper(x, ctx)))
        ) : unMapped$;
      })
    )
  );
  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery);
  const storageQueries$ = withOperationInaccessibleRecovery(
    withOptionalHash$(
      withRefcount(
        withStopRecovery(
          pinnedBlocks$,
          (hash, queries, childTrie) => recoveralStorage$(hash, queries, childTrie ?? null, false)
        )
      )
    )
  );
  const header$ = withOptionalHash$(
    withRefcount(
      withStopRecovery(
        pinnedBlocks$,
        (hash) => defer2(() => getHeader(hash))
      )
    )
  );
  merge2(runtime$, bestBlocks$).subscribe();
  const eventsAt$ = (hash) => storage$(
    hash,
    "value",
    (ctx) => ctx.events.key,
    null,
    (x, ctx) => ctx.events.dec(x)
  );
  const call$ = withOptionalHash$(
    withRefcount(withStopRecovery(pinnedBlocks$, _call$))
  );
  const validateTx$ = getValidateTx(call$);
  return {
    follow$,
    finalized$,
    best$,
    bestBlocks$,
    runtime$,
    metadata$,
    header$,
    body$,
    call$,
    storage$,
    storageQueries$,
    eventsAt$,
    validateTx$,
    trackTx$,
    withRuntime,
    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),
    unfollow
  };
};

// src/tx.ts
import { Observable as Observable18 } from "rxjs";
var tx_default = (baseTransaction) => (transaction) => new Observable18(
  (observer) => baseTransaction(transaction, (e) => {
    observer.error(e);
  })
);

// src/getObservableClient.ts
var getObservableClient = ({
  chainHead,
  transaction,
  destroy
}) => ({
  chainHead$: () => getChainHead$(chainHead),
  broadcastTx$: tx_default(transaction),
  destroy
});
export {
  BlockNotPinnedError,
  BlockPrunedError,
  NotBestBlockError,
  getObservableClient
};
//# sourceMappingURL=index.mjs.map