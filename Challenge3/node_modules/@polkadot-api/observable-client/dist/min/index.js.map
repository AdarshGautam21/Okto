{"version":3,"sources":["../../src/index.ts","../../src/utils/shareLatest.ts","../../src/utils/concatMapEager.ts","../../src/utils/with-default-value.ts","../../src/chainHead/chainHead.ts","../../src/chainHead/enhancers/operationLimitRecovery.ts","../../src/chainHead/enhancers/optionalHash.ts","../../src/chainHead/enhancers/fromAbortControllerFn.ts","../../src/chainHead/enhancers/lazyFollower.ts","../../src/chainHead/enhancers/whileBestBlock.ts","../../src/chainHead/errors.ts","../../src/chainHead/streams/follow.ts","../../src/chainHead/streams/get-runtime-creator.ts","../../src/chainHead/streams/pinned-blocks.ts","../../src/chainHead/streams/block-operations.ts","../../src/chainHead/enhancers/withStopRecovery.ts","../../src/chainHead/enhancers/operationInaccessibleRecovery.ts","../../src/chainHead/storage-queries.ts","../../src/chainHead/track-tx.ts","../../src/chainHead/validate-tx.ts","../../src/tx.ts","../../src/getObservableClient.ts"],"sourcesContent":["export * from \"./getObservableClient\"\nexport {\n  BlockNotPinnedError,\n  BlockPrunedError,\n  NotBestBlockError,\n  TrackedTx,\n} from \"./chainHead\"\n","import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n","import { concatMapEager, shareLatest } from \"@/utils\"\nimport { blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  Subject,\n  defer,\n  distinctUntilChanged,\n  map,\n  merge,\n  mergeMap,\n  scan,\n  share,\n  switchMap,\n  take,\n} from \"rxjs\"\n\nimport { withDefaultValue } from \"@/utils\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withEnsureCanonicalChain,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n  withStopRecovery,\n} from \"./enhancers\"\nimport { BlockNotPinnedError } from \"./errors\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport type {\n  BlockUsageEvent,\n  PinnedBlock,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport { getTrackTx } from \"./track-tx\"\nimport { getValidateTx } from \"./validate-tx\"\n\nexport type { FollowEventWithRuntime, RuntimeContext, SystemEvent }\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (chainHead: ChainHead) => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n        const subscription = fn(hash, ...args).subscribe(observer)\n        return () => {\n          setTimeout(() => {\n            blockUsage$.next({\n              type: \"blockUsage\",\n              value: { type: \"release\", hash },\n            })\n          }, 0)\n          subscription.unsubscribe()\n        }\n      })\n\n  const withInMemory =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        let isPresent = false\n        pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {\n          const block = blocks.blocks.get(hash)\n          isPresent = !!block && !block.unpinned\n        })\n\n        return isPresent\n          ? fn(hash, ...args).subscribe(observer)\n          : observer.error(new BlockNotPinnedError())\n      })\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) =>\n    withInMemory(\n      withRefcount(\n        withEnsureCanonicalChain(\n          pinnedBlocks$,\n          follow$,\n          withStopRecovery(\n            pinnedBlocks$,\n            withOperationInaccessibleRecovery(\n              withRecoveryFn(fromAbortControllerFn(fn)),\n            ),\n          ),\n        ),\n      ),\n    )\n\n  const _call$ = withOperationInaccessibleRecovery(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\"))),\n  )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    getHeader,\n    _call$,\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n  )\n\n  const getRuntimeContext$ = withRefcount((hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    ),\n  )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const cached = cache.get(hash)?.get(key)\n    if (cached) return cached\n\n    if (!cache.has(hash)) cache.set(hash, new Map())\n\n    const result = stream.pipe(\n      share({\n        connector: () => new ReplaySubject<T>(),\n        resetOnError: true,\n        resetOnRefCountZero: true,\n        resetOnComplete: false,\n      }),\n    )\n    cache.get(hash)!.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized)!)),\n    shareLatest,\n  )\n\n  const best$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.best === b.best),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((prev, current) => prev.best === current.best),\n    scan((acc, pinned) => {\n      const getBlockInfo = (hash: string) =>\n        acc.get(hash) || toBlockInfo(pinned.blocks.get(hash)!)\n\n      const best = getBlockInfo(pinned.best)\n      const finalized = getBlockInfo(pinned.finalized)\n\n      const len = best.number - finalized.number + 1\n      const result = new Array<BlockInfo>(len)\n      for (let i = 0, hash = best.hash; i < len; i++) {\n        result[i] = getBlockInfo(hash)\n        hash = result[i].parent\n      }\n\n      return new Map(result.map((b) => [b.hash, b]))\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((b) => b.hash)),\n    best$.pipe(map((b) => b.hash)),\n  )\n\n  const _body$ = commonEnhancer(lazyFollower(\"body\"))\n  const body$ = (hash: string) => upsertCachedStream(hash, \"body\", _body$(hash))\n  const trackTx$ = getTrackTx(pinnedBlocks$, body$)\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"))\n\n  const storage$ = withOptionalHash$(\n    <Type extends StorageItemInput[\"type\"], T>(\n      hash: string,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: (data: StorageResult<Type>, ctx: RuntimeContext) => T,\n    ): Observable<unknown extends T ? StorageResult<Type> : T> =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(map((x) => mapper(x, ctx))),\n              )\n            : unMapped$\n        }),\n      ) as Observable<unknown extends T ? StorageResult<Type> : T>,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withRefcount(\n        withStopRecovery(\n          pinnedBlocks$,\n          (\n            hash: string,\n            queries: Array<StorageItemInput>,\n            childTrie?: string,\n          ) => recoveralStorage$(hash, queries, childTrie ?? null, false),\n        ),\n      ),\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withRefcount(\n      withStopRecovery(pinnedBlocks$, (hash: string) =>\n        defer(() => getHeader(hash)),\n      ),\n    ),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe()\n\n  const eventsAt$ = (hash: string | null) =>\n    storage$(\n      hash,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    )\n\n  const call$ = withOptionalHash$(\n    withRefcount(withStopRecovery(pinnedBlocks$, _call$)),\n  )\n\n  const validateTx$ = getValidateTx(call$)\n\n  return {\n    follow$,\n    finalized$,\n    best$,\n    bestBlocks$,\n    runtime$,\n    metadata$,\n\n    header$,\n    body$,\n    call$,\n    storage$,\n    storageQueries$,\n    eventsAt$,\n\n    validateTx$,\n    trackTx$,\n    withRuntime,\n    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n    unfollow,\n  }\n}\nexport type ChainHead$ = ReturnType<typeof getChainHead$>\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        teardown(source$)\n        if (e instanceof OperationLimitError) return addTask(data, true)\n\n        observer.error(e)\n        onEmptySlot()\n      },\n      complete() {\n        observer.complete()\n        onEmptySlot()\n      },\n    })\n\n    if (!observer.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n      })\n    }\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import { Observable, mergeMap, of, take } from \"rxjs\"\n\nexport const getWithOptionalhash$ = (\n  finalized$: Observable<string>,\n  best$: Observable<string>,\n) => {\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) => {\n      const hash$ =\n        hash === null || hash === \"finalized\"\n          ? finalized$\n          : hash === \"best\"\n            ? best$\n            : of(hash)\n\n      return hash$.pipe(\n        take(1),\n        mergeMap((h) => fn(h, ...args)),\n      )\n    }\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, filter, mergeMap, switchMap, take, throwError } from \"rxjs\"\nimport { BlockPrunedError, NotBestBlockError } from \"../errors\"\nimport { PinnedBlocks, retryOnStopError } from \"../streams\"\nimport { isBestOrFinalizedBlock } from \"../streams/block-operations\"\n\nexport function withEnsureCanonicalChain<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  follow$: Observable<FollowEventWithRuntime>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) =>\n    fn(hash, ...args).pipe(\n      throwWhenPrune(\n        hash,\n        follow$.pipe(\n          retryOnStopError(),\n          filter((evt): evt is Finalized => evt.type === \"finalized\"),\n          mergeMap((evt) => evt.prunedBlockHashes),\n        ),\n      ),\n      onlyIfIsBestOrFinalized(hash, blocks$),\n    )\n}\n\nconst onlyIfIsBestOrFinalized =\n  <T>(hash: string, blocks$: Observable<PinnedBlocks>) =>\n  (source$: Observable<T>) =>\n    blocks$.pipe(\n      isBestOrFinalizedBlock(hash),\n      take(1),\n      switchMap((isBest) =>\n        isBest ? source$ : throwError(() => new NotBestBlockError()),\n      ),\n    )\n\nconst throwWhenPrune =\n  <T>(hash: string, pruned$: Observable<string>) =>\n  (source$: Observable<T>) =>\n    new Observable<T>((subscriber) => {\n      const prunedSubscription = pruned$\n        .pipe(filter((h) => h === hash))\n        .subscribe(() => {\n          subscriber.error(new BlockPrunedError())\n        })\n      const sourceSubscription = source$.subscribe(subscriber)\n\n      return () => {\n        prunedSubscription.unsubscribe()\n        sourceSubscription.unsubscribe()\n      }\n    })\n","export class BlockNotPinnedError extends Error {\n  constructor() {\n    super(\"Block is not pinned\")\n    this.name = \"BlockNotPinnedError\"\n  }\n}\n\nexport class BlockPrunedError extends Error {\n  constructor() {\n    super(\"Block pruned\")\n    this.name = \"BlockPrunedError\"\n  }\n}\n\nexport class NotBestBlockError extends Error {\n  constructor() {\n    super(\"Block is not best block or finalized\")\n    this.name = \"NotBestBlockError\"\n  }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n  StopError,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, Subscription, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse | null = null\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        follower = null\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower?.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n\nexport const retryOnStopError =\n  <T extends { type: string }>() =>\n  (source$: Observable<T>) =>\n    new Observable<\n      | T\n      | {\n          type: \"stop-error\"\n        }\n    >((observer) => {\n      const subscription = new Subscription()\n      const subscribe = () =>\n        source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => {\n            if (e instanceof StopError) {\n              observer.next({ type: \"stop-error\" })\n              subscription.add(subscribe())\n            } else {\n              observer.error(e)\n            }\n          },\n          complete: () => observer.complete(),\n        })\n      subscription.add(subscribe())\n      return subscription\n    })\n","import {\n  getChecksumBuilder,\n  getDynamicBuilder,\n  getLookupFn,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Codec,\n  Decoder,\n  SS58String,\n  Option,\n  V15,\n  u32,\n  Encoder,\n  _void,\n  Bytes,\n  metadata as metadataCodec,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { Observable, map, shareReplay } from \"rxjs\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport interface RuntimeContext {\n  metadataRaw: Uint8Array\n  metadata: V15\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  asset: [Encoder<any>, string | null]\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst opaqueMeta = Option(Bytes())\n\nconst v15Args = toHex(u32.enc(15))\nexport const getRuntimeCreator =\n  (call$: (hash: string, method: string, args: string) => Observable<string>) =>\n  (hash: string): Runtime => {\n    const usages = new Set<string>([hash])\n\n    const runtimeContext$: Observable<RuntimeContext> = call$(\n      hash,\n      \"Metadata_metadata_at_version\",\n      v15Args,\n    ).pipe(\n      map((response) => {\n        const metadataRaw = opaqueMeta.dec(response)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        if (metadata.metadata.tag !== \"v15\")\n          throw new Error(\"Wrong metadata version\")\n        const v15 = metadata.metadata.value\n        const checksumBuilder = getChecksumBuilder(v15)\n        const dynamicBuilder = getDynamicBuilder(v15)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment =\n          metadata.metadata.value.extrinsic.signedExtensions.find(\n            (x) => x.identifier === \"ChargeAssetTxPayment\",\n          )\n\n        let _assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = getLookupFn(metadata.metadata.value.lookup)(\n            assetPayment.type,\n          )\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              _assetId = optionalAssetId.value.id\n          }\n        }\n\n        const asset: [Encoder<any>, string | null] =\n          _assetId === null\n            ? [_void.enc, null]\n            : [\n                dynamicBuilder.buildDefinition(_assetId).enc,\n                checksumBuilder.buildDefinition(_assetId),\n              ]\n\n        return {\n          asset,\n          metadataRaw,\n          metadata: v15,\n          checksumBuilder,\n          dynamicBuilder,\n          events: {\n            key: events.enc(),\n            dec: events.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: hash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe()\n\n    return result\n  }\n","import { shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\nimport { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport { Observable, Subject, concatMap, map, merge, of, scan } from \"rxjs\"\nimport { retryOnStopError } from \"./follow\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\nimport { withStopRecovery } from \"../enhancers\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  refCount: number\n  unpinned?: true\n  recovering: boolean\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n  recovering: boolean\n}\n\nconst deleteBlock = (blocks: PinnedBlocks[\"blocks\"], blockHash: string) => {\n  blocks.get(blocks.get(blockHash)!.parent)?.children.delete(blockHash)\n  blocks.delete(blockHash)\n}\n\nconst getBlocksToUnpin = (blocks: PinnedBlocks, pruned: string[]) => {\n  const result: string[] = [...pruned]\n  let current = blocks.blocks.get(blocks.blocks.get(blocks.finalized)!.parent)\n\n  const trail: string[] = []\n  while (current) {\n    trail.push(current.hash)\n    if (current.refCount === 0 && !current.unpinned) {\n      result.push(current.hash)\n      current.unpinned = true\n    }\n\n    current = blocks.blocks.get(current.parent)\n  }\n\n  const deletedBlocks = [...pruned]\n  for (let i = trail.length - 1; i >= 0; i--) {\n    current = blocks.blocks.get(trail[i])!\n    if (!current.unpinned) return result\n    deletedBlocks.push(current.hash)\n  }\n\n  deletedBlocks.forEach((hash) => {\n    deleteBlock(blocks.blocks, hash)\n  })\n\n  Object.entries(blocks.runtimes)\n    .map(([key, value]) => ({\n      key,\n      usages: value.deleteBlocks(deletedBlocks),\n    }))\n    .filter((x) => x.usages === 0)\n    .map((x) => x.key)\n    .forEach((unusedRuntime) => {\n      delete blocks.runtimes[unusedRuntime]\n    })\n  return result\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEventWithRuntime>,\n  getHeader: (hash: string) => Promise<BlockHeader>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  blockUsage$: Subject<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n) => {\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    follow$.pipe(withInitializedNumber(getHeader), retryOnStopError()),\n  ).pipe(\n    scan((acc, event) => {\n      switch (event.type) {\n        case \"initialized\":\n          if (acc.recovering) {\n            const isConnected = event.finalizedBlockHashes.some((hash) =>\n              acc.blocks.has(hash),\n            )\n            if (!isConnected) {\n              acc = getInitialPinnedBlocks()\n            }\n          }\n\n          const [finalizedHash] = event.finalizedBlockHashes.slice(-1)\n          acc.finalized = acc.best = finalizedHash\n\n          const lastIdx = event.finalizedBlockHashes.length - 1\n          event.finalizedBlockHashes.forEach((hash, i) => {\n            if (acc.blocks.has(hash)) {\n              acc.blocks.get(hash)!.recovering = false\n            } else {\n              acc.blocks.set(hash, {\n                hash: hash,\n                parent:\n                  i === 0\n                    ? event.parentHash\n                    : event.finalizedBlockHashes[i - 1],\n                children: new Set(\n                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]],\n                ),\n                runtime: hash,\n                refCount: 0,\n                number: event.number + i,\n                recovering: false,\n              })\n            }\n          })\n\n          const finalizedRuntime = Object.values(acc.runtimes).find((runtime) =>\n            runtime.usages.has(finalizedHash),\n          )\n          acc.finalizedRuntime =\n            finalizedRuntime ??\n            (acc.runtimes[finalizedHash] = getRuntime(finalizedHash))\n          return acc\n\n        case \"stop-error\":\n          for (const block of acc.blocks.values()) {\n            block.recovering = true\n          }\n          acc.recovering = true\n\n          return acc\n\n        case \"newBlock\": {\n          const { parentBlockHash: parent, blockHash: hash } = event\n          if (acc.blocks.has(hash)) {\n            acc.blocks.get(hash)!.recovering = false\n          } else {\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            if (event.newRuntime) {\n              acc.runtimes[hash] = getRuntime(hash)\n              acc.runtimes[hash].runtime.subscribe()\n            }\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              refCount: 0,\n              recovering: false,\n            }\n            acc.blocks.set(hash, block)\n            acc.runtimes[block.runtime].addBlock(hash)\n          }\n\n          return acc\n        }\n\n        case \"bestBlockChanged\": {\n          if (acc.recovering) {\n            for (const [hash, block] of acc.blocks) {\n              if (block.recovering) {\n                deleteBlock(acc.blocks, hash)\n              }\n            }\n            acc.recovering = false\n          }\n          acc.best = event.bestBlockHash\n          return acc\n        }\n\n        case \"finalized\": {\n          acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n          acc.finalizedRuntime =\n            acc.runtimes[acc.blocks.get(acc.finalized)!.runtime]\n\n          // TODO: remove this once https://github.com/paritytech/polkadot-sdk/issues/3658 is fixed\n          const actuallyPruned = [...new Set(event.prunedBlockHashes)]\n\n          onUnpin(getBlocksToUnpin(acc, actuallyPruned))\n          return acc\n        }\n\n        case \"blockUsage\": {\n          if (!acc.blocks.has(event.value.hash)) return acc\n\n          const block = acc.blocks.get(event.value.hash)!\n          block.refCount += event.value.type === \"hold\" ? 1 : -1\n          if (\n            block.refCount === 0 &&\n            block.number < acc.blocks.get(acc.finalized)!.number\n          ) {\n            block.unpinned = true\n            onUnpin([block.hash])\n          }\n          return acc\n        }\n      }\n    }, getInitialPinnedBlocks()),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntime = getRuntimeCreator(withStopRecovery(pinnedBlocks$, call$))\n\n  return pinnedBlocks$\n}\n\nconst getInitialPinnedBlocks = (): PinnedBlocks => ({\n  best: \"\",\n  finalized: \"\",\n  runtimes: {},\n  blocks: new Map(),\n  finalizedRuntime: {} as Runtime,\n  recovering: false,\n})\n\nconst withInitializedNumber =\n  (getHeader: (hash: string) => Promise<BlockHeader>) =>\n  (source$: Observable<FollowEventWithRuntime>) =>\n    source$.pipe(\n      concatMap((event) => {\n        return event.type !== \"initialized\"\n          ? of(event)\n          : getHeader(event.finalizedBlockHashes[0]).then((header) => ({\n              ...event,\n              number: header.number,\n              parentHash: header.parentHash,\n            }))\n      }),\n    )\n","import {\n  Observable,\n  distinctUntilChanged,\n  filter,\n  map,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isFinalized =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.finalized === b.finalized),\n      filter(\n        (x) =>\n          x.blocks.get(x.finalized)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      take(1),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.finalized)!\n        while (current.number > number)\n          current = pinned.blocks.get(current.parent)!\n        return current.hash === blockHash\n      }),\n    )\n\nexport const isBestOrFinalizedBlock =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.best === b.best),\n      filter(\n        (x) => x.blocks.get(x.best)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.best)!\n        let isFinalized = pinned.finalized === current.hash\n        while (current.number > number) {\n          current = pinned.blocks.get(current.parent)!\n          isFinalized = isFinalized || pinned.finalized === current.hash\n        }\n        return { isBest: current.hash === blockHash, isFinalized }\n      }),\n      takeWhile(({ isFinalized }) => !isFinalized, true),\n      map(({ isBest }) => isBest),\n    )\n","import { Observable, ObservedValueOf, Subscription } from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { PinnedBlocks } from \"../streams\"\n\nexport function withStopRecovery<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) => {\n    const source$ = fn(hash, ...args)\n\n    return new Observable<ObservedValueOf<typeof source$>>((observer) => {\n      let sourceSub: Subscription | null = null\n      const performSourceSub = () => {\n        if (sourceSub) return\n        sourceSub = source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => observer.error(e),\n          complete: () => observer.complete(),\n        })\n      }\n\n      let isRecovering = false\n      const blockSub = blocks$.subscribe({\n        next: (v) => {\n          const block = v.blocks.get(hash)\n          if (!block) {\n            // This branch conflicts with BlockPrunedError, as the block might disappear when it gets pruned\n            // We can avoid this conflict by checking that we're actually recovering.\n            if (isRecovering) {\n              observer.error(new BlockNotPinnedError())\n            }\n          } else if (block.recovering) {\n            // Pause while it's recovering, as we don't know if the block is there\n            sourceSub?.unsubscribe()\n            sourceSub = null\n          } else {\n            performSourceSub()\n          }\n          isRecovering = v.recovering\n        },\n        error: (e) => observer.error(e),\n      })\n\n      return () => {\n        blockSub.unsubscribe()\n        sourceSub?.unsubscribe()\n      }\n    })\n  }\n}\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            if (nDiscarded === 0) return\n\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n","import {\n  EMPTY,\n  Observable,\n  catchError,\n  concat,\n  concatMap,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { isBestOrFinalizedBlock, isFinalized } from \"./streams/block-operations\"\n\nexport type TrackedTx =\n  | {\n      type: \"bestChainBlockIncluded\"\n      block: { hash: string; index: number }\n    }\n  | {\n      type: \"finalized\"\n      block: { hash: string; index: number }\n    }\n\nexport const getTrackTx =\n  (\n    blocks$: Observable<PinnedBlocks>,\n    getBody: (block: string) => Observable<string[]>,\n  ) =>\n  (tx: string): Observable<TrackedTx> =>\n    blocks$.pipe(\n      take(1),\n      concatMap((x) => {\n        const alreadyPresent = new Set(x.blocks.keys())\n\n        const findInBody = (hash: string): Observable<number> =>\n          alreadyPresent.has(hash)\n            ? of(-1)\n            : getBody(hash).pipe(\n                catchError(() => EMPTY),\n                takeUntil(\n                  blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))),\n                ),\n                map((txs) => txs.indexOf(tx)),\n              )\n\n        const findInBranch = (\n          hash: string,\n        ): Observable<{ hash: string; idx: number }> =>\n          findInBody(hash).pipe(\n            concatMap((idx) =>\n              idx > -1\n                ? of({ hash, idx })\n                : blocks$.pipe(\n                    takeWhile((x) => x.blocks.has(hash)),\n                    mergeMap((x) => x.blocks.get(hash)!.children),\n                    distinct(),\n                    mergeMap(findInBranch),\n                  ),\n            ),\n          )\n\n        return findInBranch(x.finalized).pipe(\n          mergeMap(({ hash, idx }) =>\n            concat(\n              blocks$.pipe(\n                isBestOrFinalizedBlock(hash),\n                filter(Boolean),\n                take(1),\n                map(() => ({\n                  type: \"bestChainBlockIncluded\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n              blocks$.pipe(\n                isFinalized(hash),\n                filter(Boolean),\n                map(() => ({\n                  type: \"finalized\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n            ),\n          ),\n        )\n      }),\n      takeWhile((x) => x.type !== \"finalized\", true),\n    )\n","import { Observable, map } from \"rxjs\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\n\nconst external = new Uint8Array([2])\n\nconst getValidateTxArgs = (tx: string, hash: string) =>\n  toHex(mergeUint8(external, fromHex(tx), fromHex(hash)))\n\nexport const getValidateTx =\n  (\n    call$: (\n      hash: string | null,\n      fnName: string,\n      parameters: string,\n    ) => Observable<string>,\n  ) =>\n  (tx: string, blockHash: string) =>\n    call$(\n      blockHash,\n      \"TaggedTransactionQueue_validate_transaction\",\n      getValidateTxArgs(tx, blockHash),\n    ).pipe(map((x) => x.startsWith(\"0x00\")))\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<never>((observer) =>\n      baseTransaction(transaction, (e) => {\n        observer.error(e)\n      }),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nexport type * from \"./chainHead\"\n\nimport { getChainHead$ } from \"./chainHead\"\nimport getBroadcastTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: () => getChainHead$(chainHead),\n  broadcastTx$: getBroadcastTx$(transaction),\n  destroy,\n})\n"],"mappings":"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","names":["src_exports","__export","BlockNotPinnedError","BlockPrunedError","NotBestBlockError","getObservableClient","__toCommonJS","import_rxjs","shareLatest","import_rxjs","concatMapEager","mapper","concurrent","source$","observer","topSubscription","queues","innerSubscriptions","results","mapperIdx","subscriptionIdx","observerIdx","nextSubscription","inner$","idx","x","e","outterValue","subscription","import_rxjs","withDefaultValue","defaultValue","source$","observer","hasEmited","subscription","v","e","import_substrate_bindings","import_substrate_client","import_rxjs","import_substrate_client","import_rxjs","PendingTaskQueue","__publicField","node","value","newNode","result","getWithRecovery","tearDownOperations","setTeardown","observable","cb","teardown","pendingTasks","unshift","push","addTask","task","topPriority","fn","onEmptySlot","data","process","source$","observer","subscription","x","e","withRecovery","pendingTask","withNormalRecovery","args","import_rxjs","getWithOptionalhash$","finalized$","best$","fn","hash","args","h","import_rxjs","fromAbortControllerFn","fn","args","observer","aborter","value","error","withLazyFollower","getFollower","key","args","import_rxjs","BlockNotPinnedError","BlockPrunedError","NotBestBlockError","import_substrate_client","import_rxjs","getFollow$","chainHead","follower","unfollow","follow$","observer","e","retryOnStopError","source$","subscription","subscribe","v","import_metadata_builders","import_substrate_bindings","import_utils","import_rxjs","opaqueMeta","v15Args","getRuntimeCreator","call$","hash","usages","runtimeContext$","response","metadataRaw","metadata","metadataCodec","v15","checksumBuilder","dynamicBuilder","events","assetPayment","x","_assetId","assetTxPayment","optionalAssetId","result","block","blocks","import_rxjs","deleteBlock","blocks","blockHash","getBlocksToUnpin","pruned","result","current","trail","deletedBlocks","i","hash","key","value","x","unusedRuntime","getPinnedBlocks$","follow$","getHeader","call$","blockUsage$","onUnpin","pinnedBlocks$","withInitializedNumber","retryOnStopError","acc","event","getInitialPinnedBlocks","finalizedHash","lastIdx","finalizedRuntime","runtime","getRuntime","block","parent","parentNode","actuallyPruned","shareLatest","getRuntimeCreator","withStopRecovery","source$","header","import_rxjs","isFinalized","blockHash","blocks$","b","a","x","pinned","number","current","isBestOrFinalizedBlock","isBest","withEnsureCanonicalChain","blocks$","follow$","fn","hash","args","throwWhenPrune","retryOnStopError","evt","onlyIfIsBestOrFinalized","source$","isBestOrFinalizedBlock","isBest","NotBestBlockError","pruned$","subscriber","prunedSubscription","h","BlockPrunedError","sourceSubscription","import_rxjs","withStopRecovery","blocks$","fn","hash","args","source$","observer","sourceSub","performSourceSub","v","e","isRecovering","blockSub","block","BlockNotPinnedError","import_substrate_client","import_rxjs","operable","source$","result","withOperationInaccessibleRecovery","fn","args","import_rxjs","getRecoveralStorage$","getFollower","withRecovery","recoveralStorage$","hash","queries","childTrie","isHighPriority","observer","items","error","nDiscarded","import_rxjs","getTrackTx","blocks$","getBody","tx","x","alreadyPresent","findInBody","hash","blocks","txs","findInBranch","idx","isBestOrFinalizedBlock","isFinalized","import_rxjs","import_utils","external","getValidateTxArgs","tx","hash","getValidateTx","call$","blockHash","x","toBlockInfo","hash","number","parent","getChainHead$","chainHead","getFollower","unfollow","follow$","getFollow$","lazyFollower","withLazyFollower","withRecovery","withRecoveryFn","getWithRecovery","blockUsage$","withRefcount","fn","args","observer","subscription","withInMemory","isPresent","pinnedBlocks$","blocks","block","BlockNotPinnedError","getHeader","unpin","hashes","e","commonEnhancer","withEnsureCanonicalChain","withStopRecovery","withOperationInaccessibleRecovery","fromAbortControllerFn","_call$","cache","getPinnedBlocks$","getRuntimeContext$","pinned","withRuntime","mapper","source$","concatMapEager","x","runtime","upsertCachedStream","key","stream","cached","result","finalized$","a","shareLatest","best$","bestBlocks$","prev","current","acc","getBlockInfo","best","finalized","len","i","b","runtime$","withDefaultValue","metadata$","withOptionalHash$","getWithOptionalhash$","_body$","body$","trackTx$","getTrackTx","_storage$","storage$","type","keyMapper","childTrie","ctx","unMapped$","recoveralStorage$","getRecoveralStorage$","storageQueries$","queries","header$","eventsAt$","call$","validateTx$","getValidateTx","import_rxjs","tx_default","baseTransaction","transaction","observer","e","getObservableClient","chainHead","transaction","destroy","getChainHead$","tx_default"]}