{"version":3,"sources":["../src/utils/shareLatest.ts","../src/utils/concatMapEager.ts","../src/utils/with-default-value.ts","../src/chainHead/chainHead.ts","../src/chainHead/enhancers/operationLimitRecovery.ts","../src/chainHead/enhancers/optionalHash.ts","../src/chainHead/enhancers/fromAbortControllerFn.ts","../src/chainHead/enhancers/lazyFollower.ts","../src/chainHead/enhancers/whileBestBlock.ts","../src/chainHead/errors.ts","../src/chainHead/streams/follow.ts","../src/chainHead/streams/get-runtime-creator.ts","../src/chainHead/streams/pinned-blocks.ts","../src/chainHead/streams/block-operations.ts","../src/chainHead/enhancers/withStopRecovery.ts","../src/chainHead/enhancers/operationInaccessibleRecovery.ts","../src/chainHead/storage-queries.ts","../src/chainHead/track-tx.ts","../src/chainHead/validate-tx.ts","../src/tx.ts","../src/getObservableClient.ts"],"sourcesContent":["import { Observable, ReplaySubject, share } from \"rxjs\"\n\nexport const shareLatest: <T>(base: Observable<T>) => Observable<T> = share({\n  connector: () => new ReplaySubject(1),\n  resetOnError: true,\n  resetOnComplete: true,\n  resetOnRefCountZero: true,\n})\n","import { defer, Observable, ObservableInput, Subscription } from \"rxjs\"\n\nexport const concatMapEager =\n  <I, O>(\n    mapper: (outterValue: I, index: number) => ObservableInput<O>,\n    concurrent = Infinity,\n  ) =>\n  (source$: Observable<I>) =>\n    new Observable<O>((observer) => {\n      let topSubscription: Subscription\n      const queues = new Map<number, Observable<O>>()\n      const innerSubscriptions = new Map<number, Subscription>()\n      const results = new Map<number, O[]>()\n\n      let mapperIdx = 0\n      let subscriptionIdx = 0\n      let observerIdx = 0\n\n      const nextSubscription = () => {\n        const inner$ = queues.get(subscriptionIdx)\n        if (!inner$) {\n          if (\n            innerSubscriptions.size === 0 &&\n            (typeof topSubscription === \"undefined\" || topSubscription.closed)\n          ) {\n            observer.complete()\n          }\n          return\n        }\n        const idx = subscriptionIdx++\n        queues.delete(idx)\n        if (observerIdx !== idx) {\n          results.set(idx, [])\n        }\n        innerSubscriptions.set(\n          idx,\n          inner$.subscribe({\n            next(x: O) {\n              if (observerIdx === idx) {\n                observer.next(x)\n              } else {\n                results.get(idx)!.push(x)\n              }\n            },\n            complete() {\n              innerSubscriptions.delete(idx)\n              if (idx === observerIdx) {\n                observerIdx++\n                while (results.has(observerIdx)) {\n                  results.get(observerIdx)!.forEach((x) => observer.next(x))\n                  results.delete(observerIdx)\n                  if (innerSubscriptions.has(observerIdx)) {\n                    break\n                  }\n                  observerIdx++\n                }\n              }\n              nextSubscription()\n            },\n            error(e: any) {\n              observer.error(e)\n            },\n          }),\n        )\n      }\n\n      topSubscription = source$.subscribe({\n        next(outterValue: I) {\n          const idx = mapperIdx++\n          queues.set(\n            idx,\n            defer(() => mapper(outterValue, idx)),\n          )\n          if (innerSubscriptions.size < concurrent) {\n            nextSubscription()\n          }\n        },\n        error(e: any) {\n          observer.error(e)\n        },\n        complete() {\n          if (innerSubscriptions.size === 0) {\n            observer.complete()\n          }\n        },\n      })\n\n      return () => {\n        innerSubscriptions.forEach((subscription) => subscription.unsubscribe())\n        topSubscription.unsubscribe()\n        queues.clear()\n        results.clear()\n      }\n    })\n","import { Observable } from \"rxjs\"\n\nexport const withDefaultValue =\n  <V, T>(defaultValue: V) =>\n  (source$: Observable<T>): Observable<V | T> =>\n    new Observable((observer) => {\n      let hasEmited = false\n\n      const subscription = source$.subscribe({\n        next(v) {\n          hasEmited = true\n          observer.next(v)\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n\n      if (!hasEmited) observer.next(defaultValue)\n\n      return subscription\n    })\n","import { concatMapEager, shareLatest } from \"@/utils\"\nimport { blockHeader } from \"@polkadot-api/substrate-bindings\"\nimport {\n  ChainHead,\n  DisjointError,\n  FollowEventWithRuntime,\n  StorageItemInput,\n  StorageResult,\n} from \"@polkadot-api/substrate-client\"\nimport {\n  Observable,\n  ReplaySubject,\n  Subject,\n  defer,\n  distinctUntilChanged,\n  map,\n  merge,\n  mergeMap,\n  scan,\n  share,\n  switchMap,\n  take,\n} from \"rxjs\"\n\nimport { withDefaultValue } from \"@/utils\"\nimport {\n  fromAbortControllerFn,\n  getWithOptionalhash$,\n  getWithRecovery,\n  withEnsureCanonicalChain,\n  withLazyFollower,\n  withOperationInaccessibleRecovery,\n  withStopRecovery,\n} from \"./enhancers\"\nimport { BlockNotPinnedError } from \"./errors\"\nimport { getRecoveralStorage$ } from \"./storage-queries\"\nimport type {\n  BlockUsageEvent,\n  PinnedBlock,\n  RuntimeContext,\n  SystemEvent,\n} from \"./streams\"\nimport { getFollow$, getPinnedBlocks$ } from \"./streams\"\nimport { getTrackTx } from \"./track-tx\"\nimport { getValidateTx } from \"./validate-tx\"\n\nexport type { FollowEventWithRuntime, RuntimeContext, SystemEvent }\n\nexport type BlockInfo = {\n  hash: string\n  number: number\n  parent: string\n}\n\nconst toBlockInfo = ({ hash, number, parent }: PinnedBlock): BlockInfo => ({\n  hash,\n  number,\n  parent,\n})\n\nexport const getChainHead$ = (chainHead: ChainHead) => {\n  const { getFollower, unfollow, follow$ } = getFollow$(chainHead)\n  const lazyFollower = withLazyFollower(getFollower)\n  const { withRecovery, withRecoveryFn } = getWithRecovery()\n\n  const blockUsage$ = new Subject<BlockUsageEvent>()\n  const withRefcount =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        blockUsage$.next({ type: \"blockUsage\", value: { type: \"hold\", hash } })\n        const subscription = fn(hash, ...args).subscribe(observer)\n        return () => {\n          setTimeout(() => {\n            blockUsage$.next({\n              type: \"blockUsage\",\n              value: { type: \"release\", hash },\n            })\n          }, 0)\n          subscription.unsubscribe()\n        }\n      })\n\n  const withInMemory =\n    <A extends Array<any>, T>(\n      fn: (hash: string, ...args: A) => Observable<T>,\n    ): ((hash: string, ...args: A) => Observable<T>) =>\n    (hash, ...args) =>\n      new Observable((observer) => {\n        let isPresent = false\n        pinnedBlocks$.pipe(take(1)).subscribe((blocks) => {\n          const block = blocks.blocks.get(hash)\n          isPresent = !!block && !block.unpinned\n        })\n\n        return isPresent\n          ? fn(hash, ...args).subscribe(observer)\n          : observer.error(new BlockNotPinnedError())\n      })\n\n  const getHeader = (hash: string) =>\n    getFollower().header(hash).then(blockHeader.dec)\n\n  const unpin = (hashes: string[]) =>\n    getFollower()\n      .unpin(hashes)\n      .catch((e) => {\n        if (e instanceof DisjointError) return\n        throw e\n      })\n\n  const commonEnhancer = <A extends Array<any>, T>(\n    fn: (\n      key: string,\n      ...args: [...A, ...[abortSignal: AbortSignal]]\n    ) => Promise<T>,\n  ) =>\n    withInMemory(\n      withRefcount(\n        withEnsureCanonicalChain(\n          pinnedBlocks$,\n          follow$,\n          withStopRecovery(\n            pinnedBlocks$,\n            withOperationInaccessibleRecovery(\n              withRecoveryFn(fromAbortControllerFn(fn)),\n            ),\n          ),\n        ),\n      ),\n    )\n\n  const _call$ = withOperationInaccessibleRecovery(\n    withRecoveryFn(fromAbortControllerFn(lazyFollower(\"call\"))),\n  )\n\n  const cache = new Map<string, Map<string, Observable<any>>>()\n  const pinnedBlocks$ = getPinnedBlocks$(\n    follow$,\n    getHeader,\n    _call$,\n    blockUsage$,\n    (blocks) => {\n      unpin(blocks)\n      blocks.forEach((hash) => {\n        cache.delete(hash)\n      })\n    },\n  )\n\n  const getRuntimeContext$ = withRefcount((hash: string) =>\n    pinnedBlocks$.pipe(\n      take(1),\n      mergeMap(\n        (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n      ),\n    ),\n  )\n\n  const withRuntime =\n    <T>(mapper: (x: T) => string) =>\n    (source$: Observable<T>): Observable<[T, RuntimeContext]> =>\n      source$.pipe(\n        concatMapEager((x) =>\n          getRuntimeContext$(mapper(x)).pipe(map((runtime) => [x, runtime])),\n        ),\n      )\n\n  const upsertCachedStream = <T>(\n    hash: string,\n    key: string,\n    stream: Observable<T>,\n  ): Observable<T> => {\n    const cached = cache.get(hash)?.get(key)\n    if (cached) return cached\n\n    if (!cache.has(hash)) cache.set(hash, new Map())\n\n    const result = stream.pipe(\n      share({\n        connector: () => new ReplaySubject<T>(),\n        resetOnError: true,\n        resetOnRefCountZero: true,\n        resetOnComplete: false,\n      }),\n    )\n    cache.get(hash)!.set(key, result)\n\n    return result\n  }\n\n  const finalized$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalized === b.finalized),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.finalized)!)),\n    shareLatest,\n  )\n\n  const best$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.best === b.best),\n    map((pinned) => toBlockInfo(pinned.blocks.get(pinned.best)!)),\n    shareLatest,\n  )\n\n  const bestBlocks$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((prev, current) => prev.best === current.best),\n    scan((acc, pinned) => {\n      const getBlockInfo = (hash: string) =>\n        acc.get(hash) || toBlockInfo(pinned.blocks.get(hash)!)\n\n      const best = getBlockInfo(pinned.best)\n      const finalized = getBlockInfo(pinned.finalized)\n\n      const len = best.number - finalized.number + 1\n      const result = new Array<BlockInfo>(len)\n      for (let i = 0, hash = best.hash; i < len; i++) {\n        result[i] = getBlockInfo(hash)\n        hash = result[i].parent\n      }\n\n      return new Map(result.map((b) => [b.hash, b]))\n    }, new Map<string, BlockInfo>()),\n    map((x) => [...x.values()]),\n    shareLatest,\n  )\n\n  const runtime$ = pinnedBlocks$.pipe(\n    distinctUntilChanged((a, b) => a.finalizedRuntime === b.finalizedRuntime),\n    switchMap(({ finalizedRuntime: { runtime } }) =>\n      runtime.pipe(withDefaultValue(null)),\n    ),\n    shareLatest,\n  )\n\n  const metadata$ = runtime$.pipe(map((x) => x?.metadata ?? null))\n\n  const withOptionalHash$ = getWithOptionalhash$(\n    finalized$.pipe(map((b) => b.hash)),\n    best$.pipe(map((b) => b.hash)),\n  )\n\n  const _body$ = commonEnhancer(lazyFollower(\"body\"))\n  const body$ = (hash: string) => upsertCachedStream(hash, \"body\", _body$(hash))\n  const trackTx$ = getTrackTx(pinnedBlocks$, body$)\n\n  const _storage$ = commonEnhancer(lazyFollower(\"storage\"))\n\n  const storage$ = withOptionalHash$(\n    <Type extends StorageItemInput[\"type\"], T>(\n      hash: string,\n      type: Type,\n      keyMapper: (ctx: RuntimeContext) => string,\n      childTrie: string | null = null,\n      mapper?: (data: StorageResult<Type>, ctx: RuntimeContext) => T,\n    ): Observable<unknown extends T ? StorageResult<Type> : T> =>\n      pinnedBlocks$.pipe(\n        take(1),\n        mergeMap(\n          (pinned) => pinned.runtimes[pinned.blocks.get(hash)!.runtime].runtime,\n        ),\n        mergeMap((ctx) => {\n          const key = keyMapper(ctx)\n          const unMapped$ = upsertCachedStream(\n            hash,\n            `storage-${type}-${key}-${childTrie ?? \"\"}`,\n            _storage$(hash, type, key, childTrie),\n          )\n\n          return mapper\n            ? upsertCachedStream(\n                hash,\n                `storage-${type}-${key}-${childTrie ?? \"\"}-dec`,\n                unMapped$.pipe(map((x) => mapper(x, ctx))),\n              )\n            : unMapped$\n        }),\n      ) as Observable<unknown extends T ? StorageResult<Type> : T>,\n  )\n\n  const recoveralStorage$ = getRecoveralStorage$(getFollower, withRecovery)\n  const storageQueries$ = withOperationInaccessibleRecovery(\n    withOptionalHash$(\n      withRefcount(\n        withStopRecovery(\n          pinnedBlocks$,\n          (\n            hash: string,\n            queries: Array<StorageItemInput>,\n            childTrie?: string,\n          ) => recoveralStorage$(hash, queries, childTrie ?? null, false),\n        ),\n      ),\n    ),\n  )\n\n  const header$ = withOptionalHash$(\n    withRefcount(\n      withStopRecovery(pinnedBlocks$, (hash: string) =>\n        defer(() => getHeader(hash)),\n      ),\n    ),\n  )\n\n  // calling `unfollow` also kills the subscription due to the fact\n  // that `follow$` completes, which makes all other streams to\n  // also complete (or error, in the case of ongoing operations)\n  merge(runtime$, bestBlocks$).subscribe()\n\n  const eventsAt$ = (hash: string | null) =>\n    storage$(\n      hash,\n      \"value\",\n      (ctx) => ctx.events.key,\n      null,\n      (x, ctx) => ctx.events.dec(x!),\n    )\n\n  const call$ = withOptionalHash$(\n    withRefcount(withStopRecovery(pinnedBlocks$, _call$)),\n  )\n\n  const validateTx$ = getValidateTx(call$)\n\n  return {\n    follow$,\n    finalized$,\n    best$,\n    bestBlocks$,\n    runtime$,\n    metadata$,\n\n    header$,\n    body$,\n    call$,\n    storage$,\n    storageQueries$,\n    eventsAt$,\n\n    validateTx$,\n    trackTx$,\n    withRuntime,\n    getRuntimeContext$: withOptionalHash$(getRuntimeContext$),\n    unfollow,\n  }\n}\nexport type ChainHead$ = ReturnType<typeof getChainHead$>\n","import { OperationLimitError } from \"@polkadot-api/substrate-client\"\nimport type { Subscriber } from \"rxjs\"\nimport { Observable } from \"rxjs\"\n\ninterface PendingTaskNode<T> {\n  value: T\n  next?: PendingTaskNode<T>\n  prev?: PendingTaskNode<T>\n}\n\nexport default class PendingTaskQueue<T> {\n  private first?: PendingTaskNode<T>\n  private last?: PendingTaskNode<T>\n\n  private getRemoveFn(node: PendingTaskNode<T>) {\n    return () => {\n      if (node.prev) {\n        node.prev.next = node.next\n      } else {\n        this.first = node.next\n      }\n\n      if (node.next) {\n        node.next.prev = node.prev\n      } else {\n        this.last = node.prev\n      }\n\n      delete node.prev\n      delete node.next\n    }\n  }\n\n  push(value: T) {\n    const newNode: PendingTaskNode<T> = { value }\n\n    if (this.last === undefined) {\n      this.last = this.first = newNode\n    } else {\n      this.last.next = newNode\n      newNode.prev = this.last\n\n      this.last = newNode\n    }\n\n    return this.getRemoveFn(newNode)\n  }\n\n  unshift(value: T) {\n    this.first = { value, next: this.first }\n    this.first.next && (this.first.next.prev = this.first)\n    this.last ||= this.first\n    return this.getRemoveFn(this.first)\n  }\n\n  pop() {\n    const result = this.first?.value\n\n    if (this.first) {\n      this.first = this.first.next\n\n      if (!this.first) {\n        this.last = undefined\n      } else {\n        delete this.first.prev?.next\n        delete this.first.prev\n      }\n    }\n\n    return result\n  }\n\n  isEmpty() {\n    return !this.first\n  }\n}\n\nexport const getWithRecovery = () => {\n  const tearDownOperations = new Map<Observable<any>, () => void>()\n\n  const setTeardown = (observable: Observable<any>, cb: () => void) => {\n    tearDownOperations.set(observable, () => {\n      tearDownOperations.delete(observable)\n      cb()\n    })\n  }\n\n  const teardown = (observable: Observable<any>) => {\n    tearDownOperations.get(observable)?.()\n  }\n\n  const pendingTasks = new PendingTaskQueue<{\n    observer: Subscriber<any>\n    source$: Observable<any>\n  }>()\n  const unshift = pendingTasks.unshift.bind(pendingTasks)\n  const push = pendingTasks.push.bind(pendingTasks)\n\n  const addTask = (\n    task: {\n      observer: Subscriber<any>\n      source$: Observable<any>\n    },\n    topPriority: boolean,\n  ) => {\n    const fn = topPriority ? unshift : push\n    setTeardown(task.source$, fn(task))\n  }\n\n  const onEmptySlot = () => {\n    const data = pendingTasks.pop()\n    if (!data) return\n\n    tearDownOperations.delete(data.source$)\n    process(data)\n  }\n\n  const process = <T>(data: {\n    observer: Subscriber<T>\n    source$: Observable<T>\n  }) => {\n    const { source$, observer } = data\n\n    const subscription = source$.subscribe({\n      next(x) {\n        observer.next(x)\n      },\n      error(e) {\n        teardown(source$)\n        if (e instanceof OperationLimitError) return addTask(data, true)\n\n        observer.error(e)\n        onEmptySlot()\n      },\n      complete() {\n        observer.complete()\n        onEmptySlot()\n      },\n    })\n\n    if (!observer.closed) {\n      setTeardown(source$, () => {\n        subscription.unsubscribe()\n      })\n    }\n  }\n\n  const withRecovery =\n    (topPriority = false) =>\n    <T>(source$: Observable<T>): Observable<T> =>\n      new Observable((observer) => {\n        const pendingTask = { observer, source$ }\n\n        if (pendingTasks.isEmpty()) {\n          process(pendingTask)\n        } else {\n          addTask(pendingTask, topPriority)\n        }\n\n        return () => {\n          teardown(source$)\n        }\n      })\n\n  const withNormalRecovery = withRecovery()\n  const withRecoveryFn =\n    <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n    (...args: Args) =>\n      withNormalRecovery(fn(...args))\n\n  return { withRecovery, withRecoveryFn }\n}\n","import { Observable, mergeMap, of, take } from \"rxjs\"\n\nexport const getWithOptionalhash$ = (\n  finalized$: Observable<string>,\n  best$: Observable<string>,\n) => {\n  return <Args extends Array<any>, T>(\n      fn: (hash: string, ...args: Args) => Observable<T>,\n    ) =>\n    (hash: string | null, ...args: Args) => {\n      const hash$ =\n        hash === null || hash === \"finalized\"\n          ? finalized$\n          : hash === \"best\"\n            ? best$\n            : of(hash)\n\n      return hash$.pipe(\n        take(1),\n        mergeMap((h) => fn(h, ...args)),\n      )\n    }\n}\n","import { Observable } from \"rxjs\"\n\nexport const fromAbortControllerFn =\n  <A extends Array<any>, T>(\n    fn: (...args: [...A, ...[abortSignal: AbortSignal]]) => Promise<T>,\n  ) =>\n  (...args: A): Observable<T> =>\n    new Observable((observer) => {\n      let aborter: AbortController | undefined = new AbortController()\n\n      fn(...[...args, aborter.signal]).then(\n        (value: any) => {\n          observer.next(value)\n          observer.complete()\n        },\n        (error: any) => {\n          observer.error(error)\n        },\n      )\n\n      return () => {\n        observer.unsubscribe()\n        aborter!.abort()\n        aborter = undefined\n      }\n    })\n","import { FollowResponse } from \"@polkadot-api/substrate-client\"\n\nexport const withLazyFollower =\n  (getFollower: () => FollowResponse) =>\n  <Key extends keyof FollowResponse>(key: Key): FollowResponse[Key] =>\n  (...args: any[]) =>\n    (getFollower() as any)[key](...args)\n","import {\n  Finalized,\n  FollowEventWithRuntime,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, filter, mergeMap, switchMap, take, throwError } from \"rxjs\"\nimport { BlockPrunedError, NotBestBlockError } from \"../errors\"\nimport { PinnedBlocks, retryOnStopError } from \"../streams\"\nimport { isBestOrFinalizedBlock } from \"../streams/block-operations\"\n\nexport function withEnsureCanonicalChain<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  follow$: Observable<FollowEventWithRuntime>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) =>\n    fn(hash, ...args).pipe(\n      throwWhenPrune(\n        hash,\n        follow$.pipe(\n          retryOnStopError(),\n          filter((evt): evt is Finalized => evt.type === \"finalized\"),\n          mergeMap((evt) => evt.prunedBlockHashes),\n        ),\n      ),\n      onlyIfIsBestOrFinalized(hash, blocks$),\n    )\n}\n\nconst onlyIfIsBestOrFinalized =\n  <T>(hash: string, blocks$: Observable<PinnedBlocks>) =>\n  (source$: Observable<T>) =>\n    blocks$.pipe(\n      isBestOrFinalizedBlock(hash),\n      take(1),\n      switchMap((isBest) =>\n        isBest ? source$ : throwError(() => new NotBestBlockError()),\n      ),\n    )\n\nconst throwWhenPrune =\n  <T>(hash: string, pruned$: Observable<string>) =>\n  (source$: Observable<T>) =>\n    new Observable<T>((subscriber) => {\n      const prunedSubscription = pruned$\n        .pipe(filter((h) => h === hash))\n        .subscribe(() => {\n          subscriber.error(new BlockPrunedError())\n        })\n      const sourceSubscription = source$.subscribe(subscriber)\n\n      return () => {\n        prunedSubscription.unsubscribe()\n        sourceSubscription.unsubscribe()\n      }\n    })\n","export class BlockNotPinnedError extends Error {\n  constructor() {\n    super(\"Block is not pinned\")\n    this.name = \"BlockNotPinnedError\"\n  }\n}\n\nexport class BlockPrunedError extends Error {\n  constructor() {\n    super(\"Block pruned\")\n    this.name = \"BlockPrunedError\"\n  }\n}\n\nexport class NotBestBlockError extends Error {\n  constructor() {\n    super(\"Block is not best block or finalized\")\n    this.name = \"NotBestBlockError\"\n  }\n}\n","import {\n  ChainHead,\n  FollowEventWithRuntime,\n  FollowResponse,\n  StopError,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, Subscription, noop, share } from \"rxjs\"\n\nexport const getFollow$ = (chainHead: ChainHead) => {\n  let follower: FollowResponse | null = null\n  let unfollow: () => void = noop\n\n  const follow$ = new Observable<FollowEventWithRuntime>((observer) => {\n    follower = chainHead(\n      true,\n      (e) => {\n        observer.next(e)\n      },\n      (e) => {\n        follower = null\n        observer.error(e)\n      },\n    )\n    unfollow = () => {\n      observer.complete()\n      follower?.unfollow()\n    }\n  }).pipe(share())\n\n  return {\n    getFollower: () => {\n      if (!follower) throw new Error(\"Missing chainHead subscription\")\n      return follower\n    },\n    unfollow: () => {\n      unfollow()\n    },\n    follow$,\n  }\n}\n\nexport const retryOnStopError =\n  <T extends { type: string }>() =>\n  (source$: Observable<T>) =>\n    new Observable<\n      | T\n      | {\n          type: \"stop-error\"\n        }\n    >((observer) => {\n      const subscription = new Subscription()\n      const subscribe = () =>\n        source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => {\n            if (e instanceof StopError) {\n              observer.next({ type: \"stop-error\" })\n              subscription.add(subscribe())\n            } else {\n              observer.error(e)\n            }\n          },\n          complete: () => observer.complete(),\n        })\n      subscription.add(subscribe())\n      return subscription\n    })\n","import {\n  getChecksumBuilder,\n  getDynamicBuilder,\n  getLookupFn,\n} from \"@polkadot-api/metadata-builders\"\nimport {\n  AccountId,\n  Codec,\n  Decoder,\n  SS58String,\n  Option,\n  V15,\n  u32,\n  Encoder,\n  _void,\n  Bytes,\n  metadata as metadataCodec,\n} from \"@polkadot-api/substrate-bindings\"\nimport { toHex } from \"@polkadot-api/utils\"\nimport { Observable, map, shareReplay } from \"rxjs\"\n\nexport type SystemEvent = {\n  phase:\n    | { type: \"ApplyExtrinsic\"; value: number }\n    | { type: \"Finalization\" }\n    | { type: \"Initialization\" }\n  event: {\n    type: string\n    value: {\n      type: string\n      value: any\n    }\n  }\n  topics: Array<any>\n}\n\nexport interface RuntimeContext {\n  metadataRaw: Uint8Array\n  metadata: V15\n  checksumBuilder: ReturnType<typeof getChecksumBuilder>\n  dynamicBuilder: ReturnType<typeof getDynamicBuilder>\n  events: {\n    key: string\n    dec: Decoder<Array<SystemEvent>>\n  }\n  accountId: Codec<SS58String>\n  asset: [Encoder<any>, string | null]\n}\n\nexport interface Runtime {\n  at: string\n  runtime: Observable<RuntimeContext>\n  addBlock: (block: string) => Runtime\n  deleteBlocks: (blocks: string[]) => number\n  usages: Set<string>\n}\n\nconst opaqueMeta = Option(Bytes())\n\nconst v15Args = toHex(u32.enc(15))\nexport const getRuntimeCreator =\n  (call$: (hash: string, method: string, args: string) => Observable<string>) =>\n  (hash: string): Runtime => {\n    const usages = new Set<string>([hash])\n\n    const runtimeContext$: Observable<RuntimeContext> = call$(\n      hash,\n      \"Metadata_metadata_at_version\",\n      v15Args,\n    ).pipe(\n      map((response) => {\n        const metadataRaw = opaqueMeta.dec(response)!\n        const metadata = metadataCodec.dec(metadataRaw)\n        if (metadata.metadata.tag !== \"v15\")\n          throw new Error(\"Wrong metadata version\")\n        const v15 = metadata.metadata.value\n        const checksumBuilder = getChecksumBuilder(v15)\n        const dynamicBuilder = getDynamicBuilder(v15)\n        const events = dynamicBuilder.buildStorage(\"System\", \"Events\")\n\n        const assetPayment =\n          metadata.metadata.value.extrinsic.signedExtensions.find(\n            (x) => x.identifier === \"ChargeAssetTxPayment\",\n          )\n\n        let _assetId: null | number = null\n        if (assetPayment) {\n          const assetTxPayment = getLookupFn(metadata.metadata.value.lookup)(\n            assetPayment.type,\n          )\n          if (assetTxPayment.type === \"struct\") {\n            const optionalAssetId = assetTxPayment.value.asset_id\n            if (optionalAssetId.type === \"option\")\n              _assetId = optionalAssetId.value.id\n          }\n        }\n\n        const asset: [Encoder<any>, string | null] =\n          _assetId === null\n            ? [_void.enc, null]\n            : [\n                dynamicBuilder.buildDefinition(_assetId).enc,\n                checksumBuilder.buildDefinition(_assetId),\n              ]\n\n        return {\n          asset,\n          metadataRaw,\n          metadata: v15,\n          checksumBuilder,\n          dynamicBuilder,\n          events: {\n            key: events.enc(),\n            dec: events.dec as any,\n          },\n          accountId: AccountId(dynamicBuilder.ss58Prefix),\n        }\n      }),\n      shareReplay(1),\n    )\n\n    const result: Runtime = {\n      at: hash,\n      runtime: runtimeContext$,\n      addBlock: (block: string) => {\n        usages.add(block)\n        return result\n      },\n      deleteBlocks: (blocks) => {\n        blocks.forEach((block) => {\n          usages.delete(block)\n        })\n        return usages.size\n      },\n      usages,\n    }\n    runtimeContext$.subscribe()\n\n    return result\n  }\n","import { shareLatest } from \"@/utils\"\nimport { BlockHeader } from \"@polkadot-api/substrate-bindings\"\nimport { FollowEventWithRuntime } from \"@polkadot-api/substrate-client\"\nimport { Observable, Subject, concatMap, map, merge, of, scan } from \"rxjs\"\nimport { retryOnStopError } from \"./follow\"\nimport { Runtime, getRuntimeCreator } from \"./get-runtime-creator\"\nimport { withStopRecovery } from \"../enhancers\"\n\nexport interface PinnedBlock {\n  hash: string\n  number: number\n  parent: string\n  children: Set<string>\n  runtime: string\n  refCount: number\n  unpinned?: true\n  recovering: boolean\n}\n\nexport interface BlockUsageEvent {\n  type: \"blockUsage\"\n  value: { type: \"hold\"; hash: string } | { type: \"release\"; hash: string }\n}\n\nexport type PinnedBlocks = {\n  best: string\n  finalized: string\n  runtimes: Record<string, Runtime>\n  blocks: Map<string, PinnedBlock>\n  finalizedRuntime: Runtime\n  recovering: boolean\n}\n\nconst deleteBlock = (blocks: PinnedBlocks[\"blocks\"], blockHash: string) => {\n  blocks.get(blocks.get(blockHash)!.parent)?.children.delete(blockHash)\n  blocks.delete(blockHash)\n}\n\nconst getBlocksToUnpin = (blocks: PinnedBlocks, pruned: string[]) => {\n  const result: string[] = [...pruned]\n  let current = blocks.blocks.get(blocks.blocks.get(blocks.finalized)!.parent)\n\n  const trail: string[] = []\n  while (current) {\n    trail.push(current.hash)\n    if (current.refCount === 0 && !current.unpinned) {\n      result.push(current.hash)\n      current.unpinned = true\n    }\n\n    current = blocks.blocks.get(current.parent)\n  }\n\n  const deletedBlocks = [...pruned]\n  for (let i = trail.length - 1; i >= 0; i--) {\n    current = blocks.blocks.get(trail[i])!\n    if (!current.unpinned) return result\n    deletedBlocks.push(current.hash)\n  }\n\n  deletedBlocks.forEach((hash) => {\n    deleteBlock(blocks.blocks, hash)\n  })\n\n  Object.entries(blocks.runtimes)\n    .map(([key, value]) => ({\n      key,\n      usages: value.deleteBlocks(deletedBlocks),\n    }))\n    .filter((x) => x.usages === 0)\n    .map((x) => x.key)\n    .forEach((unusedRuntime) => {\n      delete blocks.runtimes[unusedRuntime]\n    })\n  return result\n}\n\nexport const getPinnedBlocks$ = (\n  follow$: Observable<FollowEventWithRuntime>,\n  getHeader: (hash: string) => Promise<BlockHeader>,\n  call$: (hash: string, method: string, args: string) => Observable<string>,\n  blockUsage$: Subject<BlockUsageEvent>,\n  onUnpin: (blocks: string[]) => void,\n) => {\n  const pinnedBlocks$: Observable<PinnedBlocks> = merge(\n    blockUsage$,\n    follow$.pipe(withInitializedNumber(getHeader), retryOnStopError()),\n  ).pipe(\n    scan((acc, event) => {\n      switch (event.type) {\n        case \"initialized\":\n          if (acc.recovering) {\n            const isConnected = event.finalizedBlockHashes.some((hash) =>\n              acc.blocks.has(hash),\n            )\n            if (!isConnected) {\n              acc = getInitialPinnedBlocks()\n            }\n          }\n\n          const [finalizedHash] = event.finalizedBlockHashes.slice(-1)\n          acc.finalized = acc.best = finalizedHash\n\n          const lastIdx = event.finalizedBlockHashes.length - 1\n          event.finalizedBlockHashes.forEach((hash, i) => {\n            if (acc.blocks.has(hash)) {\n              acc.blocks.get(hash)!.recovering = false\n            } else {\n              acc.blocks.set(hash, {\n                hash: hash,\n                parent:\n                  i === 0\n                    ? event.parentHash\n                    : event.finalizedBlockHashes[i - 1],\n                children: new Set(\n                  i === lastIdx ? [] : [event.finalizedBlockHashes[i + 1]],\n                ),\n                runtime: hash,\n                refCount: 0,\n                number: event.number + i,\n                recovering: false,\n              })\n            }\n          })\n\n          const finalizedRuntime = Object.values(acc.runtimes).find((runtime) =>\n            runtime.usages.has(finalizedHash),\n          )\n          acc.finalizedRuntime =\n            finalizedRuntime ??\n            (acc.runtimes[finalizedHash] = getRuntime(finalizedHash))\n          return acc\n\n        case \"stop-error\":\n          for (const block of acc.blocks.values()) {\n            block.recovering = true\n          }\n          acc.recovering = true\n\n          return acc\n\n        case \"newBlock\": {\n          const { parentBlockHash: parent, blockHash: hash } = event\n          if (acc.blocks.has(hash)) {\n            acc.blocks.get(hash)!.recovering = false\n          } else {\n            const parentNode = acc.blocks.get(parent)!\n            parentNode.children.add(hash)\n            if (event.newRuntime) {\n              acc.runtimes[hash] = getRuntime(hash)\n              acc.runtimes[hash].runtime.subscribe()\n            }\n            const block = {\n              hash,\n              number: parentNode.number + 1,\n              parent: parent,\n              children: new Set<string>(),\n              runtime: event.newRuntime ? hash : parentNode.runtime,\n              refCount: 0,\n              recovering: false,\n            }\n            acc.blocks.set(hash, block)\n            acc.runtimes[block.runtime].addBlock(hash)\n          }\n\n          return acc\n        }\n\n        case \"bestBlockChanged\": {\n          if (acc.recovering) {\n            for (const [hash, block] of acc.blocks) {\n              if (block.recovering) {\n                deleteBlock(acc.blocks, hash)\n              }\n            }\n            acc.recovering = false\n          }\n          acc.best = event.bestBlockHash\n          return acc\n        }\n\n        case \"finalized\": {\n          acc.finalized = event.finalizedBlockHashes.slice(-1)[0]\n          acc.finalizedRuntime =\n            acc.runtimes[acc.blocks.get(acc.finalized)!.runtime]\n\n          // TODO: remove this once https://github.com/paritytech/polkadot-sdk/issues/3658 is fixed\n          const actuallyPruned = [...new Set(event.prunedBlockHashes)]\n\n          onUnpin(getBlocksToUnpin(acc, actuallyPruned))\n          return acc\n        }\n\n        case \"blockUsage\": {\n          if (!acc.blocks.has(event.value.hash)) return acc\n\n          const block = acc.blocks.get(event.value.hash)!\n          block.refCount += event.value.type === \"hold\" ? 1 : -1\n          if (\n            block.refCount === 0 &&\n            block.number < acc.blocks.get(acc.finalized)!.number\n          ) {\n            block.unpinned = true\n            onUnpin([block.hash])\n          }\n          return acc\n        }\n      }\n    }, getInitialPinnedBlocks()),\n    map((x) => ({ ...x })),\n    shareLatest,\n  )\n\n  const getRuntime = getRuntimeCreator(withStopRecovery(pinnedBlocks$, call$))\n\n  return pinnedBlocks$\n}\n\nconst getInitialPinnedBlocks = (): PinnedBlocks => ({\n  best: \"\",\n  finalized: \"\",\n  runtimes: {},\n  blocks: new Map(),\n  finalizedRuntime: {} as Runtime,\n  recovering: false,\n})\n\nconst withInitializedNumber =\n  (getHeader: (hash: string) => Promise<BlockHeader>) =>\n  (source$: Observable<FollowEventWithRuntime>) =>\n    source$.pipe(\n      concatMap((event) => {\n        return event.type !== \"initialized\"\n          ? of(event)\n          : getHeader(event.finalizedBlockHashes[0]).then((header) => ({\n              ...event,\n              number: header.number,\n              parentHash: header.parentHash,\n            }))\n      }),\n    )\n","import {\n  Observable,\n  distinctUntilChanged,\n  filter,\n  map,\n  take,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./pinned-blocks\"\n\nexport const isFinalized =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.finalized === b.finalized),\n      filter(\n        (x) =>\n          x.blocks.get(x.finalized)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      take(1),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.finalized)!\n        while (current.number > number)\n          current = pinned.blocks.get(current.parent)!\n        return current.hash === blockHash\n      }),\n    )\n\nexport const isBestOrFinalizedBlock =\n  (blockHash: string) => (blocks$: Observable<PinnedBlocks>) =>\n    blocks$.pipe(\n      takeWhile((b) => b.blocks.has(blockHash)),\n      distinctUntilChanged((a, b) => a.best === b.best),\n      filter(\n        (x) => x.blocks.get(x.best)!.number >= x.blocks.get(blockHash)!.number,\n      ),\n      map((pinned) => {\n        const { number } = pinned.blocks.get(blockHash)!\n        let current = pinned.blocks.get(pinned.best)!\n        let isFinalized = pinned.finalized === current.hash\n        while (current.number > number) {\n          current = pinned.blocks.get(current.parent)!\n          isFinalized = isFinalized || pinned.finalized === current.hash\n        }\n        return { isBest: current.hash === blockHash, isFinalized }\n      }),\n      takeWhile(({ isFinalized }) => !isFinalized, true),\n      map(({ isBest }) => isBest),\n    )\n","import { Observable, ObservedValueOf, Subscription } from \"rxjs\"\nimport { BlockNotPinnedError } from \"../errors\"\nimport { PinnedBlocks } from \"../streams\"\n\nexport function withStopRecovery<A extends Array<any>, T>(\n  blocks$: Observable<PinnedBlocks>,\n  fn: (hash: string, ...args: A) => Observable<T>,\n) {\n  return (hash: string, ...args: A) => {\n    const source$ = fn(hash, ...args)\n\n    return new Observable<ObservedValueOf<typeof source$>>((observer) => {\n      let sourceSub: Subscription | null = null\n      const performSourceSub = () => {\n        if (sourceSub) return\n        sourceSub = source$.subscribe({\n          next: (v) => observer.next(v),\n          error: (e) => observer.error(e),\n          complete: () => observer.complete(),\n        })\n      }\n\n      let isRecovering = false\n      const blockSub = blocks$.subscribe({\n        next: (v) => {\n          const block = v.blocks.get(hash)\n          if (!block) {\n            // This branch conflicts with BlockPrunedError, as the block might disappear when it gets pruned\n            // We can avoid this conflict by checking that we're actually recovering.\n            if (isRecovering) {\n              observer.error(new BlockNotPinnedError())\n            }\n          } else if (block.recovering) {\n            // Pause while it's recovering, as we don't know if the block is there\n            sourceSub?.unsubscribe()\n            sourceSub = null\n          } else {\n            performSourceSub()\n          }\n          isRecovering = v.recovering\n        },\n        error: (e) => observer.error(e),\n      })\n\n      return () => {\n        blockSub.unsubscribe()\n        sourceSub?.unsubscribe()\n      }\n    })\n  }\n}\n","import { OperationInaccessibleError } from \"@polkadot-api/substrate-client\"\nimport { Observable, catchError, concatMap, throwError, timer } from \"rxjs\"\n\nconst operable = <T>(source$: Observable<T>) => {\n  const result: Observable<T> = source$.pipe(\n    catchError((e) =>\n      e instanceof OperationInaccessibleError\n        ? timer(750).pipe(concatMap(() => result))\n        : throwError(() => e),\n    ),\n  )\n  return result\n}\n\nexport const withOperationInaccessibleRecovery =\n  <Args extends Array<any>, T>(fn: (...args: Args) => Observable<T>) =>\n  (...args: Args): Observable<T> =>\n    operable(fn(...args))\n","import {\n  FollowResponse,\n  StorageItemInput,\n  StorageItemResponse,\n} from \"@polkadot-api/substrate-client\"\nimport { Observable, mergeAll } from \"rxjs\"\nimport { getWithRecovery } from \"./enhancers\"\n\nexport const getRecoveralStorage$ = (\n  getFollower: () => FollowResponse,\n  withRecovery: ReturnType<typeof getWithRecovery>[\"withRecovery\"],\n) => {\n  const recoveralStorage$ = (\n    hash: string,\n    queries: Array<StorageItemInput>,\n    childTrie: string | null,\n    isHighPriority: boolean,\n  ): Observable<StorageItemResponse> =>\n    new Observable<StorageItemResponse[] | Observable<StorageItemResponse>>(\n      (observer) =>\n        getFollower().storageSubscription(\n          hash,\n          queries,\n          childTrie ?? null,\n          (items) => {\n            observer.next(items)\n          },\n          (error) => {\n            observer.error(error)\n          },\n          () => {\n            observer.complete()\n          },\n          (nDiscarded) => {\n            if (nDiscarded === 0) return\n\n            observer.next(\n              recoveralStorage$(\n                hash,\n                queries.slice(-nDiscarded),\n                childTrie,\n                true,\n              ),\n            )\n          },\n        ),\n    ).pipe(mergeAll(), withRecovery(isHighPriority))\n\n  return recoveralStorage$\n}\n","import {\n  EMPTY,\n  Observable,\n  catchError,\n  concat,\n  concatMap,\n  distinct,\n  filter,\n  map,\n  mergeMap,\n  of,\n  take,\n  takeUntil,\n  takeWhile,\n} from \"rxjs\"\nimport { PinnedBlocks } from \"./streams\"\nimport { isBestOrFinalizedBlock, isFinalized } from \"./streams/block-operations\"\n\nexport type TrackedTx =\n  | {\n      type: \"bestChainBlockIncluded\"\n      block: { hash: string; index: number }\n    }\n  | {\n      type: \"finalized\"\n      block: { hash: string; index: number }\n    }\n\nexport const getTrackTx =\n  (\n    blocks$: Observable<PinnedBlocks>,\n    getBody: (block: string) => Observable<string[]>,\n  ) =>\n  (tx: string): Observable<TrackedTx> =>\n    blocks$.pipe(\n      take(1),\n      concatMap((x) => {\n        const alreadyPresent = new Set(x.blocks.keys())\n\n        const findInBody = (hash: string): Observable<number> =>\n          alreadyPresent.has(hash)\n            ? of(-1)\n            : getBody(hash).pipe(\n                catchError(() => EMPTY),\n                takeUntil(\n                  blocks$.pipe(filter(({ blocks }) => !blocks.has(hash))),\n                ),\n                map((txs) => txs.indexOf(tx)),\n              )\n\n        const findInBranch = (\n          hash: string,\n        ): Observable<{ hash: string; idx: number }> =>\n          findInBody(hash).pipe(\n            concatMap((idx) =>\n              idx > -1\n                ? of({ hash, idx })\n                : blocks$.pipe(\n                    takeWhile((x) => x.blocks.has(hash)),\n                    mergeMap((x) => x.blocks.get(hash)!.children),\n                    distinct(),\n                    mergeMap(findInBranch),\n                  ),\n            ),\n          )\n\n        return findInBranch(x.finalized).pipe(\n          mergeMap(({ hash, idx }) =>\n            concat(\n              blocks$.pipe(\n                isBestOrFinalizedBlock(hash),\n                filter(Boolean),\n                take(1),\n                map(() => ({\n                  type: \"bestChainBlockIncluded\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n              blocks$.pipe(\n                isFinalized(hash),\n                filter(Boolean),\n                map(() => ({\n                  type: \"finalized\" as const,\n                  block: { hash, index: idx },\n                })),\n              ),\n            ),\n          ),\n        )\n      }),\n      takeWhile((x) => x.type !== \"finalized\", true),\n    )\n","import { Observable, map } from \"rxjs\"\nimport { fromHex, mergeUint8, toHex } from \"@polkadot-api/utils\"\n\nconst external = new Uint8Array([2])\n\nconst getValidateTxArgs = (tx: string, hash: string) =>\n  toHex(mergeUint8(external, fromHex(tx), fromHex(hash)))\n\nexport const getValidateTx =\n  (\n    call$: (\n      hash: string | null,\n      fnName: string,\n      parameters: string,\n    ) => Observable<string>,\n  ) =>\n  (tx: string, blockHash: string) =>\n    call$(\n      blockHash,\n      \"TaggedTransactionQueue_validate_transaction\",\n      getValidateTxArgs(tx, blockHash),\n    ).pipe(map((x) => x.startsWith(\"0x00\")))\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nimport { Observable } from \"rxjs\"\n\nexport default (baseTransaction: SubstrateClient[\"transaction\"]) =>\n  (transaction: string) =>\n    new Observable<never>((observer) =>\n      baseTransaction(transaction, (e) => {\n        observer.error(e)\n      }),\n    )\n","import type { SubstrateClient } from \"@polkadot-api/substrate-client\"\nexport type * from \"./chainHead\"\n\nimport { getChainHead$ } from \"./chainHead\"\nimport getBroadcastTx$ from \"./tx\"\n\nexport const getObservableClient = ({\n  chainHead,\n  transaction,\n  destroy,\n}: SubstrateClient) => ({\n  chainHead$: () => getChainHead$(chainHead),\n  broadcastTx$: getBroadcastTx$(transaction),\n  destroy,\n})\n"],"mappings":"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","names":["Observable","Observable","Observable","ReplaySubject","Subject","defer","distinctUntilChanged","map","merge","mergeMap","scan","share","switchMap","take","Observable","Observable","Observable","Observable","filter","mergeMap","take","Observable","Subscription","share","map","of","map","of","map","take","isFinalized","filter","mergeMap","take","Observable","Observable","Observable","concatMap","throwError","Observable","catchError","concatMap","filter","map","mergeMap","of","take","takeWhile","take","concatMap","of","catchError","filter","map","takeWhile","x","mergeMap","map","toHex","Subject","Observable","take","mergeMap","map","share","ReplaySubject","distinctUntilChanged","scan","switchMap","defer","merge","Observable"]}