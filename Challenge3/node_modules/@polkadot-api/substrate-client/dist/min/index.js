"use strict";var H=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var Y=Object.getOwnPropertyNames;var Z=Object.prototype.hasOwnProperty;var ee=(r,e,t)=>e in r?H(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var re=(r,e)=>{for(var t in e)H(r,t,{get:e[t],enumerable:!0})},te=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of Y(e))!Z.call(r,o)&&o!==t&&H(r,o,{get:()=>e[o],enumerable:!(n=X(e,o))||n.enumerable});return r};var oe=r=>te(H({},"__esModule",{value:!0}),r);var L=(r,e,t)=>(ee(r,typeof e!="symbol"?e+"":e,t),t);var ae={};re(ae,{DestroyedError:()=>y,DisjointError:()=>S,OperationError:()=>v,OperationInaccessibleError:()=>w,OperationLimitError:()=>E,RpcError:()=>O,StopError:()=>_,createClient:()=>se});module.exports=oe(ae);var I=require("@polkadot-api/utils"),T=r=>(...e)=>new Promise((t,n)=>{let o=I.noop,[c,l]=e[e.length-1]instanceof AbortSignal?[e.slice(0,e.length-1),e[e.length-1]]:[e],a=()=>{o(),n(new I.AbortError)};l?.addEventListener("abort",a,{once:!0});let m=d=>b=>{o=I.noop,l?.removeEventListener("abort",a),d(b)};o=r(m(t),m(n),...c)});function J(){let r=()=>{},e=()=>{};return{promise:new Promise((n,o)=>{r=n,e=o}),res:r,rej:e}}var g=()=>{};var P=()=>{let r=new Map;return{has:r.has.bind(r),subscribe(e,t){r.set(e,t)},unsubscribe(e){r.delete(e)},next(e,t){r.get(e)?.next(t)},error(e,t){let n=r.get(e);n&&(r.delete(e),n.error(t))},errorAll(e){let t=[...r.values()];r.clear(),t.forEach(n=>{n.error(e)})}}};var M=r=>r.has("transaction_v1_broadcast")?["transaction_v1_broadcast","transaction_v1_stop"]:r.has("transactionWatch_unstable_submitAndWatch")?["transactionWatch_unstable_submitAndWatch","transactionWatch_unstable_unwatch"]:["transaction_unstable_submitAndWatch","transaction_unstable_unwatch"],N=(r,e)=>(t,n)=>{let o=(a,m,d)=>r(m,[a],{onSuccess:b=>{l=b===null?g:()=>{r(d,[b])},b===null&&n(new Error("Max # of broadcasted transactions has been reached"))},onError:n}),c=!0,l=()=>{c=!1};return e instanceof Promise?e.then(M).then(a=>{c&&(l=o(t,...a))}):l=o(t,...M(e)),()=>{l()}};var _=class extends Error{constructor(){super("ChainHead stopped"),this.name="StopError"}},S=class extends Error{constructor(){super("ChainHead disjointed"),this.name="DisjointError"}},E=class extends Error{constructor(){super("ChainHead operations limit reached"),this.name="OperationLimitError"}},v=class extends Error{constructor(e){super(e),this.name="OperationError"}},w=class extends Error{constructor(){super("ChainHead operation inaccessible"),this.name="OperationInaccessibleError"}};var W=(r,e)=>t=>T((n,o,...c)=>{let[l,a]=e(...c),m=t(r,l,{onSuccess:(d,b)=>{if(d.result==="limitReached")return m=g,o(new E);let u=!0,s=g,p=f=>{u=!1,s(),n(f)},i=f=>{u=!1,s(),o(f)};s=b(d.operationId,{next:f=>{let R=f;R.event==="operationError"?o(new v(R.error)):R.event==="operationInaccessible"?o(new w):a(f,p,i)},error:i}),m=()=>{u&&(s(),t("chainHead_unstable_stopOperation",[d.operationId]))}},onError:o});return()=>{m()}});var z=W("chainHead_unstable_body",r=>[[r],(e,t)=>{t(e.value)}]);var $=W("chainHead_unstable_call",(r,e,t)=>[[r,e,t],(n,o)=>{o(n.output)}]);var G=r=>e=>new Promise((t,n)=>{r("chainHead_unstable_header",[e],{onSuccess:t,onError:n})});var D=require("@polkadot-api/utils");var k=r=>(e,t,n,o,c,l,a)=>{if(t.length===0)return l(),D.noop;let m=r("chainHead_unstable_storage",[e,t,n],{onSuccess:(d,b)=>{if(d.result==="limitReached"||d.discardedItems===t.length)return c(new E);let u=b(d.operationId,{next:i=>{switch(i.event){case"operationStorageItems":{o(i.items);break}case"operationStorageDone":{p();break}case"operationError":{s(new v(i.error));break}case"operationInaccessible":{s(new w);break}default:r("chainHead_unstable_continue",[])}},error:c});m=()=>{u(),r("chainHead_unstable_stopOperation",[d.operationId])};let s=i=>{m=D.noop,u(),c(i)},p=()=>{m=D.noop,u(),l()};a(d.discardedItems)},onError:c});return()=>{m()}};var K=r=>{let e=k(r);return T((t,n,o,c,l,a)=>{let m=c.startsWith("descendants"),d=m?[]:null,u=e(o,[{key:l,type:c}],a??null,m?s=>{d.push(s)}:s=>{d=s[0]?.[c]},n,()=>{try{t(m?d.flat():d)}catch(s){n(s)}},s=>{s>0&&(u(),n(new E))});return u})};var Q=r=>e=>e.length>0?new Promise((t,n)=>{r("chainHead_unstable_unpin",[e],{onSuccess(){t()},onError:n})}):Promise.resolve();var y=class extends Error{constructor(){super("Client destroyed"),this.name="DestroyedError"}};function ne(r){return r.operationId!==void 0}function U(r){return(e,t,n)=>{let o=P(),c=new Set,l=J(),a=l.promise,m=i=>{if(ne(i))return o.has(i.operationId)||console.warn("Uknown operationId on",i),o.next(i.operationId,i);if(i.event!=="stop"){if(i.event==="initialized")return t({type:i.event,finalizedBlockHashes:"finalizedBlockHash"in i?[i.finalizedBlockHash]:i.finalizedBlockHashes,finalizedBlockRuntime:i.finalizedBlockRuntime});let{event:f,...R}=i;return t({type:f,...R})}n(new _),s(!1)},d=i=>{n(i),s(!(i instanceof y))},s=r("chainHead_unstable_follow",[e],{onSuccess:(i,f)=>{let R=f("chainHead_unstable_followEvent",i,{next:m,error:d});s=(h=!0)=>{a=null,s=g,R(),h&&r("chainHead_unstable_unfollow",[i]),o.errorAll(new S),c.forEach(C=>{C()}),c.clear()},a=i,l.res(i)},onError:i=>{i instanceof y?s(!1):n(i),a=null,l.res(i)}}),p=(i,f,R)=>{let h=()=>{R?.onError(new S)};if(a===null)return h(),g;let C=x=>{if(!R)return r(i,[x,...f]);c.add(h);let B=(F,j)=>a===null?(j.error(new S),g):(o.subscribe(F,j),()=>{o.unsubscribe(F)}),A=r(i,[x,...f],{onSuccess:F=>{c.delete(h),R.onSuccess(F,B)},onError:F=>{c.delete(h),R.onError(F)}});return()=>{c.delete(h),A()}};if(typeof a=="string")return C(a);let q=g;return a.then(x=>{if(x instanceof Error)return h();a&&(q=C(x))}),()=>{q()}};return{unfollow(){s(),a=null},body:z(p),call:$(p),header:G(p),storage:K(p),storageSubscription:k(p),unpin:Q(p),_request:p}}}var O=class extends Error{constructor(t){super(t.message);L(this,"code");L(this,"data");this.code=t.code,this.data=t.data,this.name="RpcError"}};var ie=1,V=r=>{let e=ie++,t=new Map,n=P(),o=null,c=(b,u,s)=>{o.send(JSON.stringify({jsonrpc:"2.0",id:b,method:u,params:s}))};function l(b){try{let u,s,p,i,f,R=JSON.parse(b);if({id:u,result:s,error:p,params:i}=R,u){let C=t.get(u);return C?(t.delete(u),p?C.onError(new O(p)):C.onSuccess(s,(q,x,B)=>{let A=q+x;return n.subscribe(A,B),()=>{n.unsubscribe(A)}})):void 0}if({subscription:f,result:s,error:p}=i,!f||!p&&!Object.hasOwn(i,"result"))throw 0;let h=R.method+f;p?n.error(h,new O(p)):n.next(h,s)}catch(u){console.warn("Error parsing incomming message: "+b),console.error(u)}}o=r(l);let a=()=>{o?.disconnect(),o=null,n.errorAll(new y),t.forEach(b=>b.onError(new y)),t.clear()},m=1;return{request:(b,u,s)=>{if(!o)throw new Error("Not connected");let p=`${e}-${m++}`;return s&&t.set(p,s),c(p,b,u),()=>{t.delete(p)}},disconnect:a}};var se=r=>{let e=V(r),t=T((o,c,l,a)=>e.request(l,a,{onSuccess:o,onError:c})),n=t("rpc_methods",[]).then(o=>n=new Set(Array.isArray(o)?o:o.methods));return n.catch(g),{chainHead:U(e.request),transaction:N(e.request,n),destroy:()=>{e.disconnect()},request:t,_request:e.request}};
//# sourceMappingURL=index.js.map